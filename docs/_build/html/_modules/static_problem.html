
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>static_problem &#8212; pyjjasim 2.2.7 documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/blank.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">pyjjasim</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../pyjjasim.html">
  pyjjasim API
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
<h3><a href="../index.html">Table of Contents</a></h3>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pyjjasim.html">pyjjasim API</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for static_problem</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">ArpackNoConvergence</span>

<span class="kn">from</span> <span class="nn">pyjjasim.josephson_circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CurrentPhaseRelation&quot;</span><span class="p">,</span> <span class="s2">&quot;DefaultCPR&quot;</span><span class="p">,</span> <span class="s2">&quot;StaticProblem&quot;</span><span class="p">,</span>
           <span class="s2">&quot;StaticConfiguration&quot;</span><span class="p">,</span> <span class="s2">&quot;compute_maximal_parameter&quot;</span><span class="p">,</span>
           <span class="s2">&quot;node_to_junction_current&quot;</span><span class="p">,</span> <span class="s2">&quot;DEF_TOL&quot;</span><span class="p">,</span> <span class="s2">&quot;DEF_NEWTON_MAXITER&quot;</span><span class="p">,</span>
           <span class="s2">&quot;DEF_STAB_MAXITER&quot;</span><span class="p">,</span> <span class="s2">&quot;DEF_MAX_PAR_TOL&quot;</span><span class="p">,</span> <span class="s2">&quot;DEF_MAX_PAR_REDUCE_FACT&quot;</span><span class="p">,</span>
           <span class="s2">&quot;NewtonIterInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;ParameterOptimizeInfo&quot;</span><span class="p">,</span> <span class="s2">&quot;stability_get_preconditioner&quot;</span><span class="p">]</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Static Problem Module</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">DEF_TOL</span> <span class="o">=</span> <span class="mf">1E-10</span>

<span class="n">DEF_NEWTON_MAXITER</span> <span class="o">=</span> <span class="mi">30</span>

<span class="n">DEF_STAB_MAXITER</span> <span class="o">=</span> <span class="mi">500</span>

<span class="n">DEF_MAX_PAR_TOL</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">DEF_MAX_PAR_REDUCE_FACT</span> <span class="o">=</span> <span class="mf">0.42</span>
<span class="n">DEF_MAX_PAR_MAXITER</span> <span class="o">=</span> <span class="mi">100</span>


<div class="viewcode-block" id="CurrentPhaseRelation"><a class="viewcode-back" href="../static_problem.html#static_problem.CurrentPhaseRelation">[docs]</a><span class="k">class</span> <span class="nc">CurrentPhaseRelation</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Current-Phase relation Icp(Ic, theta). The default value is Icp = Ic * sin(theta).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : func(Ic, theta)</span>
<span class="sd">        Current-phase relation.</span>
<span class="sd">    d_func : func(Ic, theta)</span>
<span class="sd">        Derivative of current-phase relation to theta.</span>
<span class="sd">    i_func : func(Ic, theta)</span>
<span class="sd">        Integral of current-phase relation over theta (starting at 0).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">     - func, d_func and i_func must be numpy ufunc, so their output must be broadcast</span>
<span class="sd">       of input Ic and theta.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">d_func</span><span class="p">,</span> <span class="n">i_func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_func</span> <span class="o">=</span> <span class="n">d_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_func</span> <span class="o">=</span> <span class="n">i_func</span>

<div class="viewcode-block" id="CurrentPhaseRelation.eval"><a class="viewcode-back" href="../static_problem.html#static_problem.CurrentPhaseRelation.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate current phase relation; returns func(Ic, theta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="CurrentPhaseRelation.d_eval"><a class="viewcode-back" href="../static_problem.html#static_problem.CurrentPhaseRelation.d_eval">[docs]</a>    <span class="k">def</span> <span class="nf">d_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate derivative of current phase relation; returns d_func(Ic, theta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_func</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="CurrentPhaseRelation.i_eval"><a class="viewcode-back" href="../static_problem.html#static_problem.CurrentPhaseRelation.i_eval">[docs]</a>    <span class="k">def</span> <span class="nf">i_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate integral of current phase relation; returns i_func(Ic, theta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_func</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="DefaultCPR"><a class="viewcode-back" href="../static_problem.html#static_problem.DefaultCPR">[docs]</a><span class="k">class</span> <span class="nc">DefaultCPR</span><span class="p">(</span><span class="n">CurrentPhaseRelation</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Default current-phase relation Icp = Ic * sin(theta).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="k">lambda</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">th</span><span class="p">:</span> <span class="n">Ic</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">),</span>
                         <span class="k">lambda</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">th</span><span class="p">:</span> <span class="n">Ic</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">),</span>
                         <span class="k">lambda</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">th</span><span class="p">:</span> <span class="n">Ic</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)))</span></div>


<div class="viewcode-block" id="NewtonIterInfo"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo">[docs]</a><span class="k">class</span> <span class="nc">NewtonIterInfo</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Information about the newton iteration used to find static configurations.</span>
<span class="sd">    Use print(newton_iter_info) to display the information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">=</span> <span class="n">maxiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_target_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">=</span> <span class="mf">0.0</span>

<div class="viewcode-block" id="NewtonIterInfo.get_max_iter"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_max_iter">[docs]</a>    <span class="k">def</span> <span class="nf">get_max_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of iterations after which iteration is aborted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_tol"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_tol">[docs]</a>    <span class="k">def</span> <span class="nf">get_tol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_status"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns status of newton iteration result; returns value:</span>
<span class="sd">         * 0: converged. residual &lt; tolerance</span>
<span class="sd">         * 1: diverged before reaching maxiter.</span>
<span class="sd">         * 2: reached max_iter without converging or diverging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">found_target_solution</span><span class="p">())</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">)</span></div>

<div class="viewcode-block" id="NewtonIterInfo.has_converged"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.has_converged">[docs]</a>    <span class="k">def</span> <span class="nf">has_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if iteration has converged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_converged</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_is_target_vortex_configuration"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_is_target_vortex_configuration">[docs]</a>    <span class="k">def</span> <span class="nf">get_is_target_vortex_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_iters,) bool array if vortex configuration at iter</span>
<span class="sd">        agrees with vortex configuration specified in problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_target_n</span><span class="p">[:(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_iterations</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span></div>

<div class="viewcode-block" id="NewtonIterInfo.found_target_solution"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.found_target_solution">[docs]</a>    <span class="k">def</span> <span class="nf">found_target_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if has_converged() and final iter obeys target vortex config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_converged</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_target_n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iteration</span><span class="p">()]</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_number_of_iterations"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_number_of_iterations">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of newton iterations done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_iteration</span><span class="p">()</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_residual"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_residual">[docs]</a>    <span class="k">def</span> <span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_iters,) array containing residual at each iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[:(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_iterations</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span></div>

<div class="viewcode-block" id="NewtonIterInfo.get_runtime"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.get_runtime">[docs]</a>    <span class="k">def</span> <span class="nf">get_runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns runtime in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span></div>

<div class="viewcode-block" id="NewtonIterInfo.plot_residuals"><a class="viewcode-back" href="../static_problem.html#static_problem.NewtonIterInfo.plot_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">plot_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots residual vs iteration number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_is_target_vortex_configuration</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residual</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;n is target_n&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;n is not target_n&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Newton iteration number&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residual&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Evolution of residual for newton iteration.&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;newton iteration info: (tol=</span><span class="si">{</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tol</span><span class="p">()</span><span class="si">}</span><span class="s2">, maxiter=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_max_iter</span><span class="p">()</span><span class="si">}</span><span class="s2">)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;status: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (converged)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (diverged)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (indeterminate; reached max_iter without converging or diverging)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;number of iterations: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_iterations</span><span class="p">()</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;residual: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_residual</span><span class="p">()</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;runtime (in sec): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_runtime</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">is_target_n_v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_converged</span> <span class="o">=</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_target_n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_target_n_v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runtime</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParameterOptimizeInfo"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo">[docs]</a><span class="k">class</span> <span class="nc">ParameterOptimizeInfo</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Information about the parameter optimization process.</span>
<span class="sd">    Use print(parameter_optimize_info) to display a summary of</span>
<span class="sd">    the information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem_func</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="p">,</span> <span class="n">require_stability</span><span class="p">,</span> <span class="n">require_target_n</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_func</span> <span class="o">=</span> <span class="n">problem_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_tol</span> <span class="o">=</span> <span class="n">lambda_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_target_n</span> <span class="o">=</span> <span class="n">require_target_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_stability</span> <span class="o">=</span> <span class="n">require_stability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">=</span> <span class="n">maxiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_solution_at_zero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepsize_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stable_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_n_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newton_iter_infos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_step_status</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_step_stable_status</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_has_solution_at_zero"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_has_solution_at_zero">[docs]</a>    <span class="k">def</span> <span class="nf">get_has_solution_at_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if a stable target solution is found at lambda=0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_solution_at_zero</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_lambda"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_lambda">[docs]</a>    <span class="k">def</span> <span class="nf">get_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array with lambda at each step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_history</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_lambda_error"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_lambda_error">[docs]</a>    <span class="k">def</span> <span class="nf">get_lambda_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array with error in lambda.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lambda_stepsize</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_lambda_lower_bound"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_lambda_lower_bound">[docs]</a>    <span class="k">def</span> <span class="nf">get_lambda_lower_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns lower bound for lambda.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_has_solution_at_zero</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_found_solution</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_lambda_upper_bound"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_lambda_upper_bound">[docs]</a>    <span class="k">def</span> <span class="nf">get_lambda_upper_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns upper bound for lambda.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">get_found_solution</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_found_solution"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_found_solution">[docs]</a>    <span class="k">def</span> <span class="nf">get_found_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array if a stable target solution is found at step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solution_history</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_is_stable"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_is_stable">[docs]</a>    <span class="k">def</span> <span class="nf">get_is_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array if a stable target solution is found at step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stable_history</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_is_target_vortex_configuration"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_is_target_vortex_configuration">[docs]</a>    <span class="k">def</span> <span class="nf">get_is_target_vortex_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array if a solution has target vortex configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_n_history</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_newton_iter_all_info"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_newton_iter_all_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_newton_iter_all_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) list containing newton_iter_infos.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newton_iter_infos</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_newton_steps"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_newton_steps">[docs]</a>    <span class="k">def</span> <span class="nf">get_newton_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (nr_of_steps,) array with nr of newton iterations at step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">info</span><span class="o">.</span><span class="n">get_number_of_iterations</span><span class="p">()</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">newton_iter_infos</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.get_runtime"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.get_runtime">[docs]</a>    <span class="k">def</span> <span class="nf">get_runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns runtime in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span></div>

<div class="viewcode-block" id="ParameterOptimizeInfo.plot_residuals"><a class="viewcode-back" href="../static_problem.html#static_problem.ParameterOptimizeInfo.plot_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">plot_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots residual vs iteration number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n_info</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_newton_iter_all_info</span><span class="p">()):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n_info</span><span class="o">.</span><span class="n">get_is_target_vortex_configuration</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">n_info</span><span class="o">.</span><span class="n">get_residual</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Newton iteration number&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residual&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Newton residuals in parameter optimization.&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;n is target_n&quot;</span><span class="p">,</span> <span class="s2">&quot;n is not target_n&quot;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">animate_solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="nn">anim</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">lambdas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_found_solution</span><span class="p">()]</span>
        <span class="n">stable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_is_stable</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_found_solution</span><span class="p">()]</span>
        <span class="k">def</span> <span class="nf">_animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">p_fig</span><span class="p">,</span> <span class="n">p_ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
            <span class="n">p_ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lambda=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lambdas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2">, is stable: </span><span class="si">{</span><span class="n">stable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">p_ax</span><span class="p">]</span>
        <span class="n">ani</span> <span class="o">=</span> <span class="n">anim</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">_animate</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solutions</span><span class="p">)),</span>
                                 <span class="n">interval</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ani</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;Parameter optimize info:</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_has_solution_at_zero</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;Optimization failed because not solution was found at lambda=0.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">int_digit_count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">int_digit_count</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_tol</span><span class="p">),</span> <span class="n">int_digit_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_newton_steps</span><span class="p">()))</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Found lambda between </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda_lower_bound</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda_upper_bound</span><span class="p">()</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_step_stable_status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Stopped because stability could not be determined. Consider increasing stable_maxiter &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;or changing stability algorithm.)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_step_status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Stopped because newton iteration was indeterminate. Consider increasing newton_maxiter.)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Optimization reached maxiter </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maxiter</span><span class="si">}</span><span class="s2"> before reaching desired tolerance. (resid=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda_error</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; at desired tolerance (resid=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda_error</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">) </span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;runtime: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_runtime</span><span class="p">(),</span> <span class="mi">7</span><span class="p">)</span><span class="si">}</span><span class="s2"> sec</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;{0:0.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;f}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;lambda:              </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lambda</span><span class="p">()</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;bool&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;{:&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;found solution:      </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_found_solution</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_target_n</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;if so; has target n: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_is_target_vortex_configuration</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_stability</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;is so; is stable:    </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_is_stable</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;{:&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)})</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;newton step count:   </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_newton_steps</span><span class="p">()</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_preset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">has_solution_at_zero</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_solution_at_zero</span> <span class="o">=</span> <span class="n">has_solution_at_zero</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_value</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">lambda_stepsize</span><span class="p">,</span> <span class="n">found_solution</span><span class="p">,</span> <span class="n">newton_iter_info</span><span class="p">,</span> <span class="n">is_target_n</span><span class="p">,</span> <span class="n">is_stable</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepsize_history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_stepsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution_history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">found_solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stable_history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_stable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newton_iter_infos</span> <span class="o">+=</span> <span class="p">[</span><span class="n">newton_iter_info</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">solution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">solution</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_target_n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_n_history</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_target_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_step_status</span><span class="p">,</span> <span class="n">last_step_stable_status</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_step_status</span> <span class="o">=</span> <span class="n">last_step_status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_step_stable_status</span> <span class="o">=</span> <span class="n">last_step_stable_status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_lambda_stepsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize_history</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">]</span></div>


<div class="viewcode-block" id="StaticProblem"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem">[docs]</a><span class="k">class</span> <span class="nc">StaticProblem</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a static josephson junction array problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    circuit : Circuit</span>
<span class="sd">         Circuit on which the problem is based.</span>
<span class="sd">    current_sources=0.0 : (Nj,) ndarray or scalar</span>
<span class="sd">         Current sources at each junction in circuit (abbreviated Is). If scalar the same</span>
<span class="sd">         value is used for all junctions.</span>

<span class="sd">    frustration=0.0 : (Nf,) ndarray or scalar</span>
<span class="sd">         frustration, or normalized external magnetic flux, through each face in circuit</span>
<span class="sd">         (abbreviated f). If scalar the same value is used for all faces.</span>
<span class="sd">    vortex_configuration=0 : (Nf,) ndarray or scalar</span>
<span class="sd">         Target vorticity at each face in circuit (abbreviated n).  If scalar the same value is</span>
<span class="sd">         used for all faces.</span>
<span class="sd">    current_phase_relation=DefaultCPR() : CurrentPhaseRelation</span>
<span class="sd">        Current-phase relation used to do computations on problem.</span>

<span class="sd">     Notes</span>
<span class="sd">     -----</span>
<span class="sd">     - All physical quantities are dimensionless. See the UserManual (on github)</span>
<span class="sd">       for how all quantities are normalized.</span>
<span class="sd">     - It is assumed each junction has a current source, see user manual</span>
<span class="sd">       (on github) for diagram of junction. To omit the sources in particular</span>
<span class="sd">       junctions set the respective values to zero.</span>
<span class="sd">     - To use a node-based souce current (represented as an (Nn,) array Is_node</span>
<span class="sd">       with current in/e-jected at each node), convert it to a junction-based</span>
<span class="sd">       source with Is = node_to_junction_current(circuit, Is_node) and</span>
<span class="sd">       us Is as input for a static problem.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">current_sources</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">frustration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">vortex_configuration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_phase_relation</span><span class="o">=</span><span class="n">DefaultCPR</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span> <span class="o">=</span> <span class="n">circuit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">current_sources</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frustration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">frustration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vortex_configuration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">vortex_configuration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span> <span class="o">=</span> <span class="n">current_phase_relation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_sources_norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Asq_factorization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AIpLIcA_factorization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IpLIc_factorization</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Msq_factorization</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="StaticProblem.get_circuit"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_circuit">[docs]</a>    <span class="k">def</span> <span class="nf">get_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">circuit</span></div>

<div class="viewcode-block" id="StaticProblem.get_current_sources"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_current_sources">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current sources (abbreviated Is).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span></div>

<div class="viewcode-block" id="StaticProblem.get_frustration"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_frustration">[docs]</a>    <span class="k">def</span> <span class="nf">get_frustration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the frustration (abbreviated f).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frustration</span></div>

<div class="viewcode-block" id="StaticProblem.get_vortex_configuration"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_vortex_configuration">[docs]</a>    <span class="k">def</span> <span class="nf">get_vortex_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vortex configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vortex_configuration</span></div>

<div class="viewcode-block" id="StaticProblem.get_current_phase_relation"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_current_phase_relation">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_phase_relation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current-phase relation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span></div>

<div class="viewcode-block" id="StaticProblem.new_problem"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.new_problem">[docs]</a>    <span class="k">def</span> <span class="nf">new_problem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_sources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frustration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">vortex_configuration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">current_phase_relation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes copy of self with specified modifications.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">StaticProblem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="n">current_sources</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span> <span class="k">if</span> <span class="n">current_sources</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">current_sources</span><span class="p">,</span>
                             <span class="n">frustration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frustration</span> <span class="k">if</span> <span class="n">frustration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">frustration</span><span class="p">,</span>
                             <span class="n">vortex_configuration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vortex_configuration</span> <span class="k">if</span> <span class="n">vortex_configuration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">vortex_configuration</span><span class="p">,</span>
                             <span class="n">current_phase_relation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span> <span class="k">if</span> <span class="n">current_phase_relation</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">current_phase_relation</span><span class="p">)</span></div>

<div class="viewcode-block" id="StaticProblem.get_phase_zone"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_phase_zone">[docs]</a>    <span class="k">def</span> <span class="nf">get_phase_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the phase zone (In all of pyJJAsim phase_zone=0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="StaticProblem.get_net_sourced_current"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_net_sourced_current">[docs]</a>    <span class="k">def</span> <span class="nf">get_net_sourced_current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the sum of all (positive) current injected at nodes to create Is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cut_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">M</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">())),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="StaticProblem.get_node_current_sources"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.get_node_current_sources">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_current_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nn,) array of currents injected at nodes to create Is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cut_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">M</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span></div>

<div class="viewcode-block" id="StaticProblem.approximate"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.approximate">[docs]</a>    <span class="k">def</span> <span class="nf">approximate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes approximate solutions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        algorithm=1:</span>
<span class="sd">            Algorithm used in approximation. Can have values:</span>
<span class="sd">             * 0: Does arctan approximation. This assigns phases that &quot;wind&quot; 2*pi around</span>
<span class="sd">               vortices in z=0 phase zone, phi(x,y) = sum_i 2 * pi * n_i *</span>
<span class="sd">               atan2(y-y_n_i,x-x_n_i) where vortices are located at centres of their</span>
<span class="sd">               respective faces.</span>
<span class="sd">             * 1: London approximation. Find theta in cycle space (theta = A.T @ ...)</span>
<span class="sd">               that obeys winding rule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">arctan_approximation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nt</span><span class="p">(),</span>
                                         <span class="n">Asq_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Asq_factorization</span><span class="p">(),</span>
                                         <span class="n">IpLIc_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_IpLIc_factorization</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">london_approximation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nt</span><span class="p">(),</span>
                                         <span class="n">AIpLIcA_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AIpLIcA_factorization</span><span class="p">())</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">change_phase_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">(),</span> <span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nt</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid algorithm&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StaticConfiguration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="StaticProblem.approximate_placed_vortices"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.approximate_placed_vortices">[docs]</a>    <span class="k">def</span> <span class="nf">approximate_placed_vortices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x_n</span><span class="p">,</span> <span class="n">y_n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute arctan approximation with manual placement of vortices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : (N,) int array</span>
<span class="sd">            Vorticity at location (x_n, y_n).</span>
<span class="sd">        x_n, y_n : (N,) float arrays</span>
<span class="sd">            The x,y-coordinates of vortices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">arctan_approximation_placed_vortices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">x_n</span><span class="p">,</span> <span class="n">y_n</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Asq_factorization</span><span class="p">(),</span> <span class="n">IpLIc_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_IpLIc_factorization</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">StaticConfiguration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="StaticProblem.compute"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_NEWTON_MAXITER</span><span class="p">,</span>
                <span class="n">stop_as_residual_increases</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stop_if_not_target_n</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute solution to static_problem using Newton iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_guess=None : (Nj,) array, StaticConfiguration or None</span>
<span class="sd">            Guess for initial state. If None; uses London approximation. If input                 None (London approximation is used)</span>
<span class="sd">            is array; it must contain values of theta to represent state.</span>

<span class="sd">        tol=DEF_TOL : scalar</span>
<span class="sd">            Tolerance; is solution if |residual| &lt; tol.</span>
<span class="sd">        maxiter=DEF_NEWTON_MAXITER : int</span>
<span class="sd">            Maximum number of newton iterations.</span>
<span class="sd">        stop_if_not_target_n=False : bool</span>
<span class="sd">            Iteration stops  if n(iter) != n (diverged)</span>
<span class="sd">        stop_as_residual_increases=True : bool</span>
<span class="sd">            Iteration stops if error(iter) &gt; error(iter - 3) (diverged).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        config : StaticConfiguration</span>
<span class="sd">            Object containing solution.</span>
<span class="sd">        status : int</span>
<span class="sd">            * 0: converged</span>
<span class="sd">            * 1: diverged if error(iter)&gt;0.5 or above reasons.</span>
<span class="sd">            * 2: max_iter reached without converging or diverging.</span>
<span class="sd">        iter_info :  NewtonIterInfo</span>
<span class="sd">            Handle containing information about newton iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approximate</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">,</span> <span class="n">StaticConfiguration</span><span class="p">):</span>
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">initial_guess</span><span class="o">.</span><span class="n">_th</span><span class="p">()</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">iter_info</span> <span class="o">=</span> <span class="n">static_compute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">(),</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">Is</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">(),</span>
                                                  <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">(),</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nt</span><span class="p">(),</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">cp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
                                                  <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Asq_factorization</span><span class="p">(),</span>
                                                  <span class="n">stop_as_residual_increases</span><span class="o">=</span><span class="n">stop_as_residual_increases</span><span class="p">,</span>
                                                  <span class="n">stop_if_not_target_n</span><span class="o">=</span><span class="n">stop_if_not_target_n</span><span class="p">)</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">StaticConfiguration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">config</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">iter_info</span></div>


<div class="viewcode-block" id="StaticProblem.compute_frustration_bounds"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.compute_frustration_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">compute_frustration_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="n">start_frustration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="o">=</span><span class="n">DEF_MAX_PAR_TOL</span><span class="p">,</span>
                                   <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_MAX_PAR_MAXITER</span><span class="p">,</span> <span class="n">require_stability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">require_vortex_configuration_equals_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">compute_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stability_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>


<span class="sd">        Computes smallest and largest uniform frustration for which a (stable) solution</span>
<span class="sd">        exists at the specified target vortex configuration and source current.</span>

<span class="sd">        For unlisted parameters see documentation of compute_maximal_parameter()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_frustration=None : valid frustration input for StaticProblem  or None.</span>
<span class="sd">            Frustration factor somewhere in the middle of range. If None; this is</span>
<span class="sd">            estimated based on vortex configuration.</span>
<span class="sd">        initial_guess=None : valid initial_guess input for StaticProblem.compute()</span>
<span class="sd">            Initial guess for the algorithm to start at frustration=start_frustration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (smallest_f_factor, largest_f_factor) : (float, float)</span>
<span class="sd">            Resulting frustration range.</span>
<span class="sd">        (smallest_f_config, largest_f_config) : (StaticConfiguration, StaticConfiguration)</span>
<span class="sd">            StaticConfigurations at bounds of range.</span>
<span class="sd">        (smallest_f_info, largest_f_info) : (ParameterOptimizeInfo, ParameterOptimizeInfo)</span>
<span class="sd">             ParameterOptimizeInfo objects containing information about the iterations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_tol&quot;</span><span class="p">:</span> <span class="n">lambda_tol</span><span class="p">,</span> <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">,</span> <span class="s2">&quot;compute_parameters&quot;</span><span class="p">:</span> <span class="n">compute_parameters</span><span class="p">,</span>
                   <span class="s2">&quot;stability_parameters&quot;</span><span class="p">:</span> <span class="n">stability_parameters</span><span class="p">,</span> <span class="s2">&quot;require_stability&quot;</span><span class="p">:</span> <span class="n">require_stability</span><span class="p">,</span>
                   <span class="s2">&quot;require_vortex_configuration_equals_target&quot;</span><span class="p">:</span> <span class="n">require_vortex_configuration_equals_target</span><span class="p">}</span>


        <span class="k">if</span> <span class="n">start_frustration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_frustration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nt</span><span class="p">())</span>
        <span class="n">frustration_initial_stepsize</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">problem_small_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">frustration</span><span class="o">=</span><span class="n">start_frustration</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">problem_large_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">frustration</span><span class="o">=</span><span class="n">start_frustration</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">compute_maximal_parameter</span><span class="p">(</span><span class="n">problem_small_func</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
                                        <span class="n">estimated_upper_bound</span><span class="o">=</span><span class="n">frustration_initial_stepsize</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">smallest_factor</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">smallest_f_config</span><span class="p">,</span> <span class="n">smallest_f_info</span> <span class="o">=</span> <span class="n">out</span>
        <span class="n">smallest_f</span> <span class="o">=</span> <span class="n">start_frustration</span> <span class="o">-</span> <span class="n">smallest_factor</span> <span class="k">if</span> <span class="n">smallest_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">compute_maximal_parameter</span><span class="p">(</span><span class="n">problem_large_func</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
                                        <span class="n">estimated_upper_bound</span><span class="o">=</span><span class="n">frustration_initial_stepsize</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="n">largest_factor</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">largest_f_config</span><span class="p">,</span> <span class="n">largest_f_info</span> <span class="o">=</span> <span class="n">out</span>
        <span class="n">largest_f</span> <span class="o">=</span> <span class="n">start_frustration</span> <span class="o">+</span> <span class="n">largest_factor</span> <span class="k">if</span> <span class="n">largest_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">smallest_f</span><span class="p">,</span> <span class="n">largest_f</span><span class="p">),</span> <span class="p">(</span><span class="n">smallest_f_config</span><span class="p">,</span> <span class="n">largest_f_config</span><span class="p">),</span> <span class="p">(</span><span class="n">smallest_f_info</span><span class="p">,</span> <span class="n">largest_f_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="StaticProblem.compute_maximal_current"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.compute_maximal_current">[docs]</a>    <span class="k">def</span> <span class="nf">compute_maximal_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="o">=</span><span class="n">DEF_MAX_PAR_TOL</span><span class="p">,</span>
                                <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_MAX_PAR_MAXITER</span><span class="p">,</span> <span class="n">require_stability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">require_vortex_configuration_equals_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">compute_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stability_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes largest source current for which a stable solution exists at the</span>
<span class="sd">        specified target vortex configuration and frustration, where the  source</span>
<span class="sd">        current is assumed to be max_current_factor * self.get_current_sources().</span>

<span class="sd">        For parameters see documentation of compute_maximal_parameter()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_current_factor : float</span>
<span class="sd">            Maximal current factor for which a problem with max_current_factor * Is</span>
<span class="sd">            has a (stable) solution.</span>
<span class="sd">        net_sources_current : float</span>
<span class="sd">            Net sourced current at max_current_factor.</span>
<span class="sd">        out_config : StaticConfiguration</span>
<span class="sd">            StaticConfiguration of state with maximal current.</span>
<span class="sd">        info : ParameterOptimizeInfo</span>
<span class="sd">            ParameterOptimizeInfo objects containing information about the iterations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">Nj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Mr</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Nj</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Problem must contain nonzero current sources.&quot;</span><span class="p">)</span>
        <span class="n">Is_per_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">())</span>
        <span class="n">max_super_I_per_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Ic</span><span class="p">()</span>
        <span class="n">current_factor_initial_stepsize</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Is_per_node</span> <span class="o">/</span> <span class="n">max_super_I_per_node</span><span class="p">)</span>
        <span class="n">problem_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">current_sources</span><span class="o">=</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">())</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">compute_maximal_parameter</span><span class="p">(</span><span class="n">problem_func</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
                                        <span class="n">lambda_tol</span><span class="o">=</span><span class="n">lambda_tol</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                        <span class="n">estimated_upper_bound</span><span class="o">=</span><span class="n">current_factor_initial_stepsize</span><span class="p">,</span>
                                        <span class="n">compute_parameters</span><span class="o">=</span><span class="n">compute_parameters</span><span class="p">,</span>
                                        <span class="n">stability_parameters</span><span class="o">=</span><span class="n">stability_parameters</span><span class="p">,</span>
                                        <span class="n">require_stability</span><span class="o">=</span><span class="n">require_stability</span><span class="p">,</span>
                                        <span class="n">require_vortex_configuration_equals_target</span><span class="o">=</span>
                                        <span class="n">require_vortex_configuration_equals_target</span><span class="p">)</span>
        <span class="n">max_current_factor</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">out_config</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">out</span>
        <span class="n">net_I</span> <span class="o">=</span> <span class="n">out_config</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">get_net_sourced_current</span><span class="p">()</span> <span class="k">if</span> <span class="n">out_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">max_current_factor</span><span class="p">,</span> <span class="n">net_I</span><span class="p">,</span> <span class="n">out_config</span><span class="p">,</span> <span class="n">info</span></div>

<div class="viewcode-block" id="StaticProblem.compute_stable_region"><a class="viewcode-back" href="../static_problem.html#static_problem.StaticProblem.compute_stable_region">[docs]</a>    <span class="k">def</span> <span class="nf">compute_stable_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">61</span><span class="p">),</span> <span class="n">start_frustration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">start_initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="o">=</span><span class="n">DEF_MAX_PAR_TOL</span><span class="p">,</span>
                              <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_MAX_PAR_MAXITER</span><span class="p">,</span> <span class="n">require_stability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">require_vortex_configuration_equals_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">compute_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stability_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds edge of stable region in (f, Is) space for vortex configuration n.</span>

<span class="sd">        The frustration is assumed to be uniform. Ignores self.frustration and</span>
<span class="sd">        works with constant * self.current_sources.</span>

<span class="sd">        For unlisted parameters see documentation of compute_maximal_parameter()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles=np.linspace(0, 2*np.pi, 61) : array</span>
<span class="sd">            Angles at which an extremum in (f, Is) space is searched for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frustration : (num_angles,) array</span>
<span class="sd">            Net extermum frustration at each angle.</span>
<span class="sd">        net_current : (num_angles,) array</span>
<span class="sd">            Net extremum sourced current at each angle.</span>
<span class="sd">        all_configs : list containing StaticConfiguration</span>
<span class="sd">            Configurations at extreme value for each angle.</span>
<span class="sd">        all_infos : list containing ParameterOptimizeInfo</span>
<span class="sd">            Objects containing information about the iterations at each angle.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_angles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lambda_tol&quot;</span><span class="p">:</span> <span class="n">lambda_tol</span><span class="p">,</span> <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">,</span> <span class="s2">&quot;compute_parameters&quot;</span><span class="p">:</span> <span class="n">compute_parameters</span><span class="p">,</span>
                   <span class="s2">&quot;stability_parameters&quot;</span><span class="p">:</span> <span class="n">stability_parameters</span><span class="p">,</span> <span class="s2">&quot;require_stability&quot;</span><span class="p">:</span> <span class="n">require_stability</span><span class="p">,</span>
                   <span class="s2">&quot;require_vortex_configuration_equals_target&quot;</span><span class="p">:</span> <span class="n">require_vortex_configuration_equals_target</span><span class="p">}</span>

        <span class="n">frust_bnd_prb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">current_sources</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">frust_bnd_prb</span><span class="o">.</span><span class="n">compute_frustration_bounds</span><span class="p">(</span><span class="n">initial_guess</span><span class="o">=</span><span class="n">start_initial_guess</span><span class="p">,</span>
                                                       <span class="n">start_frustration</span><span class="o">=</span><span class="n">start_frustration</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

        <span class="p">(</span><span class="n">smallest_f</span><span class="p">,</span> <span class="n">largest_f</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">if</span> <span class="n">smallest_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">dome_center_f</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">smallest_f</span> <span class="o">+</span> <span class="n">largest_f</span><span class="p">)</span>
        <span class="n">dome_center_problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">frustration</span><span class="o">=</span><span class="n">dome_center_f</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dome_center_problem</span><span class="o">.</span><span class="n">compute_maximal_current</span><span class="p">(</span><span class="n">initial_guess</span><span class="o">=</span><span class="n">start_initial_guess</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="n">max_current_factor</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">if</span> <span class="n">max_current_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">frustration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="n">net_current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_angles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="n">all_configs</span><span class="p">,</span> <span class="n">all_infos</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">angle_nr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_angles</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">angle_nr</span><span class="p">]</span>
            <span class="n">Is_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Is</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_current_factor</span>
            <span class="n">f_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dome_center_f</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">largest_f</span> <span class="o">-</span> <span class="n">smallest_f</span><span class="p">))</span>
            <span class="n">problem_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_problem</span><span class="p">(</span><span class="n">frustration</span><span class="o">=</span><span class="n">f_func</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">current_sources</span><span class="o">=</span><span class="n">Is_func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">compute_maximal_parameter</span><span class="p">(</span><span class="n">problem_func</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="n">start_initial_guess</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
            <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">out_config</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">net_current</span><span class="p">[</span><span class="n">angle_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_config</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">get_net_sourced_current</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">frustration</span><span class="p">[</span><span class="n">angle_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_func</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span> <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">all_configs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">out_config</span><span class="p">]</span>
            <span class="n">all_infos</span> <span class="o">+=</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">frustration</span><span class="p">,</span> <span class="n">net_current</span><span class="p">,</span> <span class="n">all_configs</span><span class="p">,</span> <span class="n">all_infos</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;static problem: &quot;</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">current sources: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_current_sources</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">frustration: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_frustration</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">vortex configuration: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vortex_configuration</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">phase zone: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_phase_zone</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">current-phase relation: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_Is</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span>

    <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frustration</span>

    <span class="k">def</span> <span class="nf">_nt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vortex_configuration</span>

    <span class="k">def</span> <span class="nf">_cp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dcp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span><span class="o">.</span><span class="n">d_eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_icp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_phase_relation</span><span class="o">.</span><span class="n">i_eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Is_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sources_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_sources_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_sources</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sources_norm</span>

    <span class="k">def</span> <span class="nf">_Asq_factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Asq_factorization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Asq_factorization</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Asq_factorization</span>

    <span class="k">def</span> <span class="nf">_AIpLIcA_factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AIpLIcA_factorization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Nj</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">()</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">Ic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_L</span><span class="p">(),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Ic</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AIpLIcA_factorization</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Nj</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">Ic</span><span class="p">)</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">AIpLIcA_factorization</span>

    <span class="k">def</span> <span class="nf">_IpLIc_factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IpLIc_factorization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Nj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Nj</span><span class="p">()</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">Ic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_L</span><span class="p">(),</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Ic</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IpLIc_factorization</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Nj</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">Ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">IpLIc_factorization</span>

    <span class="k">def</span> <span class="nf">_Msq_factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msq_factorization</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Mr</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Msq_factorization</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Msq_factorization</span></div>


<span class="k">class</span> <span class="nc">StaticConfiguration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximation or solution to static problem.</span>

<span class="sd">    It is defined by a StaticProblem and theta. Here theta must be a</span>
<span class="sd">    numpy array of shape (Nj,).</span>

<span class="sd">    Provides methods to compute all physical quantities associated with the state.</span>
<span class="sd">    The quantities are dimensionless, see the user manual (on github) for a list</span>
<span class="sd">    of definitions.</span>

<span class="sd">    Furthermore provides a .plot() method to visualize the quantities superimposed</span>
<span class="sd">    on the circuit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : StaticProblem</span>
<span class="sd">        Static problem object for which this is an approximation or solution.</span>
<span class="sd">    theta : (Nj,) array</span>
<span class="sd">        Gauge invariant phase differences at each junction, which fully encodes</span>
<span class="sd">        the state.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">:</span> <span class="n">StaticProblem</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;theta must be of shape (Nj,)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns circuit (stored in problem).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_problem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StaticProblem</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the static problem this configuration is associated with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span>

    <span class="k">def</span> <span class="nf">get_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nn,) array containing phases at each node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># by default the last node (node with highest index number) is grounded.</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">Msq_solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Mr</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">_Msq_factorization</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Msq_solver</span><span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">()),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nj,) array containing gauge invariant phase difference at each junction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>

    <span class="k">def</span> <span class="nf">get_n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nf,) int array containing vorticity at each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">tpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_I</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nj,) array containing current through each junction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">_cp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Ic</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_J</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nf,) array containing path current around each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">Asq_solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">_Asq_factorization</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Asq_solver</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_I</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nf,) array containing magnetic flux at each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">()</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">frustration</span> <span class="o">+</span> <span class="n">A</span> <span class="o">@</span> <span class="n">L</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_I</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_EM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nj,) array containing magnetic energy at each junction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span> <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_I</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_EJ</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (Nj,) array containing Josephson energy at each junction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">_icp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">()</span><span class="o">.</span><span class="n">_Ic</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_Etot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns get_EM() + get_EJ().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_EJ</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_EM</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">satisfies_kirchhoff_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if configuration satisfies Kirchhoff&#39;s current law.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_kirchhoff_rules</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="k">def</span> <span class="nf">satisfies_winding_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if configuration satisfies the winding rules.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_winding_rules</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span>

    <span class="k">def</span> <span class="nf">satisfies_target_vortices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if vortex configuration equals that of problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get_vortex_configuration</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">is_stable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_STAB_MAXITER</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">accept_ratio</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a configuration is dynamically stable.</span>

<span class="sd">        The criterion for stability is that the Jacobian matrix of the time-evolution at the</span>
<span class="sd">        stationairy point is negative definite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        maxiter=DEF_STAB_MAXITER : int</span>
<span class="sd">                maximum number of iterations to determine if solutions are stable</span>
<span class="sd">        scheme=0 : int</span>
<span class="sd">            Scheme for what Jaccobian to compute to determine if the system is</span>
<span class="sd">            stable. 0 works for all cases; 1 does not work if there is mixed inductance,</span>
<span class="sd">            meaning only some faces have any inductance associated with them.</span>
<span class="sd">        algorithm=0 : int</span>
<span class="sd">            Algorithm used to find eigenvalues. 0 uses eigsh to find eigenvalues, 1 uses lobpcg.</span>
<span class="sd">        accept_ratio=10 : int (only if algorithm=1)</span>
<span class="sd">            Parameter used by lobpcg_test_negative_definite.</span>
<span class="sd">        preconditioner : {None, &quot;auto&quot;, sparse/dense matrix or LinearOperator} (only if algorithm=1)</span>
<span class="sd">            Uses preconditioner which must approximate inv(J). If None, no preconditioner is used.</span>
<span class="sd">            if &quot;auto&quot;, automatically computes preconditioner using stability_get_preconditioner().</span>
<span class="sd">            Note that this is independent of theta and can be used for multiple problems.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        status : int</span>
<span class="sd">            0: stable, 1: unstable or 2: indeterminate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">get_current_phase_relation</span><span class="p">()</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">compute_stability</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">(),</span> <span class="n">cp</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                   <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">accept_ratio</span><span class="o">=</span><span class="n">accept_ratio</span><span class="p">,</span>
                                   <span class="n">preconditioner</span><span class="o">=</span><span class="n">preconditioner</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">is_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if configuration is a solution meaning it must satisfy both Kirchhoff</span>
<span class="sd">        current law and winding rules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies_kirchhoff_rules</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies_winding_rules</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_target_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if configuration is a solution and its vortex_configuration equals</span>
<span class="sd">        the one specified in problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_solution</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies_target_vortices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_stable_target_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">,</span> <span class="n">stable_maxiter</span><span class="o">=</span><span class="n">DEF_STAB_MAXITER</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if configuration is a solution, is stable and its vortex_configuration equals</span>
<span class="sd">        the one specified in problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_target_solution</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_stable</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="n">stable_maxiter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_error_kirchhoff_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns normalized residual of kirchhoff&#39;s rules (normalized so cannot exceed 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_kirchhoff_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_I</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span><span class="o">.</span><span class="n">_Is</span><span class="p">(),</span>
                                   <span class="n">precomputed_Is_norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">_Is_norm</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_error_winding_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns normalized residual of the winding rules (normalized so cannot exceed 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">circuit</span><span class="p">,</span> <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_problem</span><span class="p">()</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">Asq_factorized</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">_f</span><span class="p">(),</span>  <span class="n">problem</span><span class="o">.</span><span class="n">_Asq_factorization</span><span class="p">()</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">get_winding_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_th</span><span class="p">()</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_I</span><span class="p">(),</span> <span class="n">get_g</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="n">Asq_factorized</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns get_error_kirchhoff_rules(), get_error_winding_rules().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_kirchhoff_rules</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_winding_rules</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_quantity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">junction_quantity</span><span class="o">=</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="n">face_quantity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">vortex_quantity</span><span class="o">=</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">show_grid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize static configuration on circuit.</span>

<span class="sd">        See :py:attr:`circuit_visualize.CircuitPlot` for documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyjjasim.circuit_visualize</span> <span class="kn">import</span> <span class="n">ConfigPlot</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_handle</span> <span class="o">=</span> <span class="n">ConfigPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vortex_quantity</span><span class="o">=</span><span class="n">vortex_quantity</span><span class="p">,</span> <span class="n">show_grid</span><span class="o">=</span><span class="n">show_grid</span><span class="p">,</span>
                                      <span class="n">junction_quantity</span><span class="o">=</span><span class="n">junction_quantity</span><span class="p">,</span>  <span class="n">show_nodes</span><span class="o">=</span><span class="n">show_nodes</span><span class="p">,</span>
                                      <span class="n">node_quantity</span><span class="o">=</span><span class="n">node_quantity</span><span class="p">,</span> <span class="n">face_quantity</span><span class="o">=</span><span class="n">face_quantity</span><span class="p">,</span>
                                      <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_handle</span>

    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kirchhoff rules error:    &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_kirchhoff_rules</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path rules error:         &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_error_winding_rules</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is stable:                &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stable</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is target vortex solution:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfies_target_vortices</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_th</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">UTILITY ALGORITHMS</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">get_kirchhoff_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Is</span><span class="p">,</span> <span class="n">precomputed_Is_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Residual of kirchhoffs current law: M @ (I - Is) = 0. Normalized; so between 0 and 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">precomputed_Is_norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">precomputed_Is_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Is</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cut_matrix</span><span class="p">()</span> <span class="o">@</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">Is</span><span class="p">)</span>
    <span class="n">M_norm</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_get_M_norm</span><span class="p">()</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">M_norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">precomputed_Is_norm</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normalizer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1E-20</span> <span class="k">else</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">normalizer</span>

<span class="k">def</span> <span class="nf">get_winding_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">th_p</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Residual of winding rule: A @ (thp - g) = 0. Normalized; so between 0 and 1.</span>
<span class="sd">    (where thp = th + L @ I)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">()</span>
    <span class="n">A_norm</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_get_A_norm</span><span class="p">()</span>
    <span class="n">normalizer</span> <span class="o">=</span> <span class="n">A_norm</span> <span class="o">*</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">th_p</span><span class="p">)</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normalizer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1E-20</span> <span class="k">else</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">th_p</span> <span class="o">-</span> <span class="n">g</span><span class="p">))</span> <span class="o">/</span> <span class="n">normalizer</span>

<span class="k">def</span> <span class="nf">principle_value</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Principle value of angle quantity defined as its value in range [-pi, pi)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">theta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">get_g</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    g vector obeying A @ g = 2 * pi * (z - f)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">Nf</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nf</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">Asq_solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Asq_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Asq_solver</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">Nf</span><span class="p">,)))</span>

<span class="k">def</span> <span class="nf">change_phase_zone</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">z_old</span><span class="p">,</span> <span class="n">z_new</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts solution theta in old phase zone z_old to the equivalent</span>
<span class="sd">    state theta_out in new phase zone z_new.</span>

<span class="sd">    More precisely: adds multiples of 2*pi to theta such that it obeys</span>
<span class="sd">    A @ (th_new + L @ I) = 2 * pi * (z_new - f)</span>
<span class="sd">    (assuming it already satisfied A @ (th_old + L @ I) = 2 * pi * (z_old- f))</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    circuit : Circuit</span>
<span class="sd">        Circuit.</span>
<span class="sd">    theta : (Nj,) array</span>
<span class="sd">        Theta in old phase zone.</span>
<span class="sd">    z_old : (Nf,) int array</span>
<span class="sd">        Old phase zone.</span>
<span class="sd">    z_new : (Nf,) int array</span>
<span class="sd">        New phase zone.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta_new : (Nj,) array</span>
<span class="sd">        Theta expressed in new phase zone.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_A_solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">z_new</span> <span class="o">-</span> <span class="n">z_old</span><span class="p">,</span> <span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">_Nf</span><span class="p">(),))</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<div class="viewcode-block" id="node_to_junction_current"><a class="viewcode-back" href="../static_problem.html#static_problem.node_to_junction_current">[docs]</a><span class="k">def</span> <span class="nf">node_to_junction_current</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">node_current</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conversion from node_current to junction_current.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node_current : (Nn,) array</span>
<span class="sd">        At each node how much current is injected or ejected  (+ if injected)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    junction_current: (Nj,) array</span>
<span class="sd">        Returns a configuration of currents at each junction such that at any node</span>
<span class="sd">        the net injected current through all its neighbouring edges matches the specified</span>
<span class="sd">        node_current.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Mr</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Mr</span><span class="p">()</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">Mr</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Mr</span> <span class="o">@</span> <span class="n">Mr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">node_current</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">PARAMETER MAXIMIZATION ALGORITHMS</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="compute_maximal_parameter"><a class="viewcode-back" href="../static_problem.html#static_problem.compute_maximal_parameter">[docs]</a><span class="k">def</span> <span class="nf">compute_maximal_parameter</span><span class="p">(</span><span class="n">problem_function</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="o">=</span><span class="n">DEF_MAX_PAR_TOL</span><span class="p">,</span>
                              <span class="n">estimated_upper_bound</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_MAX_PAR_MAXITER</span><span class="p">,</span>
                              <span class="n">stepsize_reduction_factor</span><span class="o">=</span><span class="n">DEF_MAX_PAR_REDUCE_FACT</span><span class="p">,</span> <span class="n">require_stability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">require_vortex_configuration_equals_target</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">compute_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stability_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the largest value of lambda for which problem_function(lambda)</span>
<span class="sd">    has a stable stationary state.</span>

<span class="sd">     - Must be able to find a stable configuration at lambda=0.</span>
<span class="sd">     - One can manually specify an initial_guess for lambda=0.</span>
<span class="sd">     - returns a lower- and upperbound for lambda. Stops when the difference &lt; lambda_tol * lower_bound</span>
<span class="sd">     - furthermore returns config containing the solutions at the lower_bound. Also its</span>
<span class="sd">       accompanied problem has f and Is of lower_bound.</span>
<span class="sd">     - Also returns ParameterOptimizeInfo object containing information about the iteration.</span>
<span class="sd">     - Algorithm stops if lambda_tol is reached or when newton_iteration failed to converge or diverge.</span>
<span class="sd">     - Algorithm needs an estimate of the upperbound for lambda to work.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem_function : func(lambda) -&gt; StaticProblem</span>
<span class="sd">        Function with argument the optimization parameter lambda returning a valid</span>
<span class="sd">        StaticProblem object.</span>
<span class="sd">    initial_guess=None : valid initial_guess input for StaticProblem.compute()</span>
<span class="sd">        Initial guess for problem_function(0) used as starting point for iteration.</span>
<span class="sd">    lambda_tol=DEF_MAX_PAR_TOL : float</span>
<span class="sd">        Target precision for parameter lambda. Stops iterating if</span>
<span class="sd">        upperbound - lowerbound &lt; lambda_tol * lower_bound.</span>
<span class="sd">    estimated_upper_bound=1.0 : float</span>
<span class="sd">        Estimate for the upperbound for lambda.</span>
<span class="sd">    maxiter=DEF_MAX_PAR_MAXITER : int</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    stepsize_reduction_factor=DEF_MAX_PAR_REDUCE_FACT : float</span>
<span class="sd">        Lambda is multiplied by this factor every time an upper_bound is found.</span>
<span class="sd">    require_stability=True : bool</span>
<span class="sd">        If True, convergence to a state that is dynamically unstable is</span>
<span class="sd">        considered diverged. (see StaticConfiguration.is_stable())</span>
<span class="sd">    require_vortex_configuration_equals_target=True : bool</span>
<span class="sd">        If True, A result of .compute() is only considered a solution if its</span>
<span class="sd">        vortex configuration matches its set &quot;target&quot; vortex configuration</span>
<span class="sd">        in the source static_problem.</span>
<span class="sd">    compute_parameters: dict or func(lambda) -&gt; dict</span>
<span class="sd">        Keyword-argument parameters passed to problem_function(lambda).compute()</span>
<span class="sd">        defined as a dictionary or as a function with lambda as input that</span>
<span class="sd">        generates a dictionary.</span>
<span class="sd">    stability_parameters: dict or func(lambda) -&gt; dict</span>
<span class="sd">        Keyword-argument parameters passed to config.is_stable() defined as a</span>
<span class="sd">        dictionary or as a function with lambda as input that generates a dictionary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lambda_lowerbound : float</span>
<span class="sd">        Lowerbound of lambda.</span>
<span class="sd">    lambda_upperbound : float</span>
<span class="sd">        Upperbound of lambda.</span>
<span class="sd">    config : StaticConfiguration</span>
<span class="sd">        Containing solutions at lambda=lambda_lowerbound</span>
<span class="sd">    iteration_info : ParameterOptimizeInfo</span>
<span class="sd">        Object containing information about the iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">compute_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compute_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">stability_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stability_parameters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">stable_status</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># prepare info handle</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">ParameterOptimizeInfo</span><span class="p">(</span><span class="n">problem_function</span><span class="p">,</span> <span class="n">lambda_tol</span><span class="p">,</span> <span class="n">require_stability</span><span class="p">,</span>
                                 <span class="n">require_vortex_configuration_equals_target</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">)</span>

    <span class="c1"># determine solution at lambda=0</span>
    <span class="n">cur_problem</span> <span class="o">=</span> <span class="n">problem_function</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">cur_problem</span><span class="o">.</span><span class="n">approximate</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">,</span> <span class="n">StaticConfiguration</span><span class="p">):</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">initial_guess</span><span class="o">.</span><span class="n">_th</span><span class="p">()</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">initial_guess</span>
    <span class="n">compute_param</span> <span class="o">=</span> <span class="n">compute_parameters</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compute_parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">compute_parameters</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">cur_problem</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">initial_guess</span><span class="o">=</span><span class="n">theta0</span><span class="p">,</span> <span class="o">**</span><span class="n">compute_param</span><span class="p">)</span>
    <span class="n">config</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">newton_iter_info</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">is_solution</span> <span class="o">=</span> <span class="n">status</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">require_vortex_configuration_equals_target</span><span class="p">:</span>
        <span class="n">is_target_vortex_config</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">satisfies_target_vortices</span><span class="p">()</span>
        <span class="n">is_solution</span> <span class="o">&amp;=</span> <span class="n">is_target_vortex_config</span>
    <span class="k">if</span> <span class="n">is_solution</span> <span class="ow">and</span> <span class="n">require_stability</span><span class="p">:</span>
        <span class="n">stab_param</span> <span class="o">=</span> <span class="n">stability_parameters</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stability_parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">stability_parameters</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stable_status</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">is_stable</span><span class="p">(</span><span class="o">**</span><span class="n">stab_param</span><span class="p">)</span>
        <span class="n">is_solution</span> <span class="o">&amp;=</span> <span class="n">stable_status</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">theta</span>

    <span class="n">info</span><span class="o">.</span><span class="n">_preset</span><span class="p">(</span><span class="n">is_solution</span><span class="p">)</span>

    <span class="c1"># return if no solution at lambda=0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_solution</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info</span>

    <span class="c1"># prepare iteration to find maximum lambda</span>
    <span class="n">found_upper_bound</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">lambda_stepsize</span> <span class="o">=</span> <span class="n">estimated_upper_bound</span>
    <span class="n">lambda_val</span> <span class="o">=</span> <span class="n">lambda_stepsize</span>
    <span class="n">theta0</span> <span class="o">=</span> <span class="n">theta</span>

    <span class="c1"># start iteration to find maximum lambda</span>
    <span class="n">iter_nr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

        <span class="c1"># determine solution at current lambda</span>
        <span class="n">cur_problem</span> <span class="o">=</span> <span class="n">problem_function</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">)</span>
        <span class="n">compute_param</span> <span class="o">=</span> <span class="n">compute_parameters</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compute_parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">compute_parameters</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">cur_problem</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">initial_guess</span><span class="o">=</span><span class="n">theta0</span><span class="p">,</span> <span class="o">**</span><span class="n">compute_param</span><span class="p">)</span>
        <span class="n">config</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">newton_iter_info</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">has_converged</span> <span class="o">=</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">require_vortex_configuration_equals_target</span> <span class="ow">and</span> <span class="n">has_converged</span><span class="p">:</span>
            <span class="n">is_target_vortex_config</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">satisfies_target_vortices</span><span class="p">()</span>
            <span class="n">has_converged</span> <span class="o">&amp;=</span> <span class="n">is_target_vortex_config</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_target_vortex_config</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">theta</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">require_stability</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_converged</span><span class="p">:</span>
                <span class="n">stab_param</span> <span class="o">=</span> <span class="n">stability_parameters</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stability_parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">stability_parameters</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">)</span>
                <span class="n">stable_status</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">is_stable</span><span class="p">(</span><span class="o">**</span><span class="n">stab_param</span><span class="p">)</span>
                <span class="n">is_stable</span> <span class="o">=</span> <span class="n">stable_status</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_stable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">is_solution</span> <span class="o">=</span> <span class="n">has_converged</span> <span class="ow">and</span> <span class="n">is_stable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_stable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">is_solution</span> <span class="o">=</span> <span class="n">has_converged</span>

        <span class="c1"># update information on current iteration in info handle</span>
        <span class="n">info</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">,</span> <span class="n">config</span> <span class="k">if</span> <span class="n">has_converged</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lambda_stepsize</span><span class="p">,</span>
                  <span class="n">has_converged</span><span class="p">,</span> <span class="n">newton_iter_info</span><span class="p">,</span> <span class="n">is_target_vortex_config</span><span class="p">,</span> <span class="n">is_stable</span><span class="p">)</span>

        <span class="c1"># determine new lambda value to try (and corresponding initial condition)</span>
        <span class="k">if</span> <span class="n">is_solution</span><span class="p">:</span>
            <span class="n">lambda_val</span> <span class="o">+=</span> <span class="n">lambda_stepsize</span>
            <span class="n">theta0</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lambda_val</span> <span class="o">-=</span> <span class="n">lambda_stepsize</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">stepsize_reduction_factor</span><span class="p">)</span>
            <span class="n">lambda_stepsize</span><span class="o">*=</span><span class="n">stepsize_reduction_factor</span>
            <span class="n">found_upper_bound</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lambda_stepsize</span> <span class="o">/</span> <span class="n">lambda_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">lambda_tol</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">iter_nr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">maxiter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">require_stability</span> <span class="ow">and</span> <span class="n">has_converged</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stable_status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">iter_nr</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># determine lower- and upperbound on lambda</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_finish</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">stable_status</span><span class="p">)</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">lambda_val</span> <span class="o">-</span> <span class="n">lambda_stepsize</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">lambda_val</span> <span class="k">if</span> <span class="n">found_upper_bound</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_problem</span> <span class="o">=</span> <span class="n">problem_function</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">StaticConfiguration</span><span class="p">(</span><span class="n">out_problem</span><span class="p">,</span> <span class="n">theta0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">info</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">APPROXIMATE STATE FINDING ALGORITHMS</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">london_approximation</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">AIpLIcA_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core algorithm computing london approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">Nf</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span>  <span class="n">circuit</span><span class="o">.</span><span class="n">_Nf</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">AIpLIcA_solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">()</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">Ic</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Ic</span><span class="p">()</span>
        <span class="n">AIpLIcA_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Nj</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">Ic</span><span class="p">)</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">AIpLIcA_solver</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">Nf</span><span class="p">,)))</span>

<span class="k">def</span> <span class="nf">arctan_approximation</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IpLIc_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    arctan_approximation implemented in arctan_approximation_placed_vortices()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">centr_x</span><span class="p">,</span> <span class="n">centr_y</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_face_centroids</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">arctan_approximation_placed_vortices</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centr_x</span><span class="p">[</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centr_y</span><span class="p">[</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span>
                                                <span class="n">Asq_solver</span><span class="o">=</span><span class="n">Asq_solver</span><span class="p">,</span> <span class="n">IpLIc_solver</span><span class="o">=</span><span class="n">IpLIc_solver</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">arctan_approximation_placed_vortices</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x_n</span><span class="p">,</span> <span class="n">y_n</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IpLIc_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core algorithm computing arctan approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">x_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x_n</span><span class="p">)</span>
    <span class="n">y_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y_n</span><span class="p">)</span>
    <span class="n">MT</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cut_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">IpLIc_solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">()</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">Ic</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Ic</span><span class="p">()</span>
        <span class="n">IpLIc_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Nj</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">Ic</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_node_coordinates</span><span class="p">()</span>
    <span class="n">MTphi</span> <span class="o">=</span> <span class="n">MT</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_n</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_n</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">*</span> <span class="n">n</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">principle_value</span><span class="p">(</span><span class="n">MTphi</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_g</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="n">Asq_solver</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">IpLIc_solver</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">MTphi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">STATIONAIRY STATE FINDING ALGORITHMS</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">static_compute</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">Is</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">cp</span><span class="o">=</span><span class="n">DefaultCPR</span><span class="p">(),</span> <span class="n">tol</span><span class="o">=</span><span class="n">DEF_TOL</span><span class="p">,</span>
                   <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_NEWTON_MAXITER</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">stop_as_residual_increases</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stop_if_not_target_n</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core algorithm computing stationary state of a Josephson Junction Circuit using Newtons method.</span>

<span class="sd">    Stand-alone method. The wrappers StaticProblem and StaticConfiguration are more convenient.</span>

<span class="sd">    Status</span>
<span class="sd">    ------</span>
<span class="sd">    Stops iterating if ( -&gt; status):</span>
<span class="sd">     - residual is smaller than tol, target_n: 0 (converged)</span>
<span class="sd">     - residual smaller than tol, not target_n:  1 (diverged)</span>
<span class="sd">     - iteration number iter exceeds maxiter: 2 (indeterminate)</span>
<span class="sd">     - residual exceeds 0.5: 1 (diverged)</span>
<span class="sd">     - if get_n(theta) != n and stop_if_not_target_n==True: 1 (diverged)</span>
<span class="sd">     - resid(iter) &gt; resid(iter-3) and stop_as_residual_increases==True : 1 (diverged)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------</span>
<span class="sd">    circuit: Circuit</span>
<span class="sd">        Josephson junction circuit</span>
<span class="sd">    theta0 : (Nj,) ndarray</span>
<span class="sd">        Initial guess</span>
<span class="sd">    Is : (Nj,) ndarray</span>
<span class="sd">        Current sources at each junction</span>
<span class="sd">    f : (Nf,) ndarray</span>
<span class="sd">        Frustration in each face</span>
<span class="sd">    n : (Nf,) int ndarray</span>
<span class="sd">        Number of vortices in each face</span>
<span class="sd">    z=0 : (Nf,) int ndarray or scalar</span>
<span class="sd">        Phase zone of each face</span>
<span class="sd">    cp=DefaultCPR() : CurrentPhaseRelation</span>
<span class="sd">        Current phase relation</span>
<span class="sd">    tol=DEF_TOL :  scalar</span>
<span class="sd">        Tolerance. is solution if |residual| &lt; tol.</span>
<span class="sd">    max_iter=100 :  scalar</span>
<span class="sd">        Maximum number of newton iterations.</span>
<span class="sd">    Asq_solver=None :  func: vector-&gt;vector</span>
<span class="sd">        Solver for A @ A.T @ x == b. If None, set equal to scipy.sparse.linalg.factorized(A @ A.T)</span>
<span class="sd">    stop_as_residual_increases=True : bool</span>
<span class="sd">        Iteration stops if error(iter) &gt; error(iter - 3)</span>
<span class="sd">    stop_if_not_target_n=False : bool</span>
<span class="sd">        Iteration stops if n != target_n</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : (Nj,) ndarray</span>
<span class="sd">        Gauge invariant phase difference of solution</span>
<span class="sd">    convergence_status : int</span>
<span class="sd">        * 0 -&gt; converged</span>
<span class="sd">        * 1 -&gt; diverged</span>
<span class="sd">        * 2 -&gt; max_iter reached without converging or diverging.</span>
<span class="sd">    info : NewtonIterInfo</span>
<span class="sd">        Information about iteration (timing, steps, residuals, etc)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prepare newton iter info</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">NewtonIterInfo</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">)</span>

    <span class="c1"># get circuit quantities and matrices</span>
    <span class="n">Nj</span><span class="p">,</span> <span class="n">Nf</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nf</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cut_matrix</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">()</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
    <span class="n">Ic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">get_critical_current_factors</span><span class="p">(),</span> <span class="p">(</span><span class="n">Nj</span><span class="p">,))</span>

    <span class="n">Is</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nj</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">Is</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Is</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Is</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nf</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">f</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nf</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span>

    <span class="c1"># iteration-0 computations</span>
    <span class="k">if</span> <span class="n">Asq_solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Asq_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">get_g</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">Asq_solver</span><span class="o">=</span><span class="n">Asq_solver</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">Is_norm</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Is</span><span class="p">)</span>

    <span class="c1"># iteration-0 compute errors</span>
    <span class="n">error1</span> <span class="o">=</span> <span class="n">get_kirchhoff_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Is</span><span class="p">,</span>  <span class="n">precomputed_Is_norm</span><span class="o">=</span><span class="n">Is_norm</span><span class="p">)</span>
    <span class="n">error2</span> <span class="o">=</span> <span class="n">get_winding_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">I</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="n">error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">error1</span><span class="p">,</span> <span class="n">error2</span><span class="p">)</span>
    <span class="n">is_target_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">is_target_n</span><span class="p">)</span>

    <span class="c1"># prepare newton iteration</span>
    <span class="n">prev_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">stop_if_not_target_n</span> <span class="ow">and</span> <span class="n">is_target_n</span><span class="p">)</span> <span class="ow">or</span>
               <span class="p">(</span><span class="n">stop_as_residual_increases</span> <span class="ow">and</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">prev_error</span><span class="p">)</span> <span class="ow">or</span> <span class="n">iteration</span> <span class="o">&gt;=</span> <span class="n">maxiter</span><span class="p">):</span>
        <span class="c1"># iteration computations</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">d_eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">M</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">Nj</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))])</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">J_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">M</span> <span class="o">@</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">Is</span><span class="p">),</span> <span class="n">A</span> <span class="o">@</span>  <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">g</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">I</span><span class="p">)])</span>
        <span class="n">theta</span> <span class="o">-=</span> <span class="n">J_solver</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="c1"># iteration error computations</span>
        <span class="n">error1</span> <span class="o">=</span> <span class="n">get_kirchhoff_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">Is</span><span class="p">,</span> <span class="n">precomputed_Is_norm</span><span class="o">=</span><span class="n">Is_norm</span><span class="p">)</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="n">get_winding_error</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">L</span> <span class="o">@</span> <span class="n">I</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">error1</span><span class="p">,</span> <span class="n">error2</span><span class="p">)</span>
        <span class="n">is_target_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="n">z</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">is_target_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">prev_error</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">error</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span>

        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">get_status</span><span class="p">(),</span> <span class="n">info</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">STABILITY ALGORITHMS</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">compute_stability</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_STAB_MAXITER</span><span class="p">,</span>
                      <span class="n">scheme</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">accept_ratio</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core implementation to determine if a configuration on a circuit is stable in the sense that</span>
<span class="sd">    the Jacobian is negative definite. Does not explicitly check if configuration is a stationairy point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    circuit : Circuit</span>
<span class="sd">        Circuit</span>
<span class="sd">    theta : (Nj,) array</span>
<span class="sd">        Gauge invariant phase difference of static configuration of circuit.</span>
<span class="sd">    cp : CurrentPhaseRelation</span>
<span class="sd">        Current-phase relation.</span>
<span class="sd">    maxiter=DEF_STAB_MAXITER : int</span>
<span class="sd">        Maximum number of iterations done to determine stability.</span>
<span class="sd">    algorithm=0 : int</span>
<span class="sd">        Algorithm used. 0 uses eigsh to find eigenvalues, 1 uses lobpcg.</span>
<span class="sd">    accept_ratio :</span>
<span class="sd">        Parameter used by lobpcg_test_negative_definite (if algorithm=1).</span>
<span class="sd">    preconditioner : {sparse matrix, dense matrix, LinearOperator, None or &quot;auto&quot;}</span>
<span class="sd">        Only if algorithm is 1. Uses preconditioner which must approximate inv(J).</span>
<span class="sd">        If None, no preconditioner is used. if &quot;auto&quot;, automatically computes preconditioner</span>
<span class="sd">        using stability_get_preconditioner(). Note that this is independent of theta and can</span>
<span class="sd">        be used for multiple problems.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    status : int</span>
<span class="sd">        0: stable, 1: unstable or 2: indeterminate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">stability_scheme_0</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">stability_scheme_1</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">largest_eigenvalue</span> <span class="o">=</span> <span class="n">eigsh_test_negative_definite</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span>
    <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">preconditioner</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">preconditioner</span> <span class="o">=</span> <span class="n">stability_get_preconditioner</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">lobpcg_test_negative_definite</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="n">preconditioner</span><span class="p">,</span> <span class="n">accept_ratio</span><span class="o">=</span><span class="n">accept_ratio</span><span class="p">,</span>
                                            <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">)</span>
        <span class="n">status</span><span class="p">,</span> <span class="n">eigenvalue_list</span><span class="p">,</span> <span class="n">residual_list</span> <span class="o">=</span> <span class="n">out</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">residual_list</span><span class="p">),</span> <span class="n">residual_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">status</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid algorithm. Must be 0 (eigsh) or 1 (lobpcg)&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">stability_get_preconditioner</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">scheme</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute preconditioner to determine stability</span>

<span class="sd">    Scheme 1 with inductance cannot be preconditioned.</span>

<span class="sd">    Note that this preconditioner is independent of theta, so can be reused</span>
<span class="sd">    for multiple problems. Generating a preconditioner is slow as it does</span>
<span class="sd">    a factorization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;YO&quot;</span><span class="p">)</span>
    <span class="n">Nj</span><span class="p">,</span> <span class="n">Nnr</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nnr</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">d_eval</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">_Ic</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nj</span><span class="p">))</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Mr</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">AL</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">L</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
        <span class="n">ALL</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">AL</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">AL</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">Nnr</span><span class="p">,</span> <span class="n">AL</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">Nnr</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nj</span><span class="p">,</span> <span class="n">Nj</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">M</span><span class="p">,</span> <span class="n">A</span> <span class="o">@</span> <span class="n">L</span><span class="p">])</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">ALL</span><span class="p">)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">select</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">select</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_has_inductance</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scheme 1 with inductance cannot be preconditioned.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="o">-</span> <span class="n">M</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>
    <span class="n">X_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">matvec</span><span class="o">=</span><span class="n">X_solver</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">stability_scheme_0</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scheme to determine matrix for which the system is stable if it is negative definite.</span>

<span class="sd">    Works for mixed inductance but generally slower than scheme 1.</span>

<span class="sd">    Scheme 0: matrix is:</span>
<span class="sd">     * J = m @ X @ m.T</span>
<span class="sd">     * where X = -grad cp(Ic, theta) - A.T @ inv(A @ L @ A.T) @ A</span>
<span class="sd">     * and m = [M ; A @ L]</span>
<span class="sd">     * all-zero rows and columns are removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Nj</span><span class="p">,</span> <span class="n">Nnr</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nnr</span><span class="p">()</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span>  <span class="n">circuit</span><span class="o">.</span><span class="n">_Mr</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
    <span class="n">Ic</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Ic</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">d_eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">AL</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">L</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
    <span class="n">ALL</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">AL</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">AL</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">Nnr</span><span class="p">,</span> <span class="n">AL</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">Nnr</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nj</span><span class="p">,</span> <span class="n">Nj</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">M</span><span class="p">,</span> <span class="n">A</span> <span class="o">@</span> <span class="n">L</span><span class="p">])</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="n">J</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">ALL</span><span class="p">)</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">select</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">select</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">J</span>

<span class="k">def</span> <span class="nf">stability_scheme_1</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scheme to determine matrix for which the system is stable if it is negative definite.</span>

<span class="sd">    Generally faster than scheme 0 but does not work for mixed inductance (where only some</span>
<span class="sd">    faces have any inductance associated with them).</span>

<span class="sd">    Scheme 1: matrix is:</span>
<span class="sd">     * if L=0: J = -M @ grad cp(Ic, theta) @ M.T</span>
<span class="sd">     * if L!=0: J = -grad cp(Ic, theta) - A.T @ inv(A @ L @ A.T) @ A</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_has_mixed_inductance</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scheme 1 does not allow mixed inductance.&quot;</span><span class="p">)</span>
    <span class="n">Ic</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Ic</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">d_eval</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_has_inductance</span><span class="p">():</span>
        <span class="n">Nj</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Nj</span><span class="p">()</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">get_cycle_matrix</span><span class="p">(),</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_L</span><span class="p">()</span>
        <span class="n">ALA_solver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">L</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Nj</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">q</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">ALA_solver</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">((</span><span class="n">Nj</span><span class="p">,</span> <span class="n">Nj</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">_Mr</span><span class="p">()</span>
        <span class="n">J</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span> <span class="o">@</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">J</span>

<span class="k">def</span> <span class="nf">eigsh_test_negative_definite</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_STAB_MAXITER</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if symmetric matrix A is negative definite using eigsh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : {sparse matrix, dense matrix, LinearOperator}</span>
<span class="sd">        Matrix to determine if positive definite</span>
<span class="sd">    maxiter=200 :</span>
<span class="sd">        Maximum number of iterations. If exceeded; result is indeterminate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    status : int</span>
<span class="sd">        0: negative definite, 1: not negative definite or 2: indeterminate</span>
<span class="sd">    largest_eigenvalue : float</span>
<span class="sd">        Largest eigenvalue determined by eigsh algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LA&quot;</span><span class="p">)</span>
        <span class="n">largest_eigenvalue</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_stable</span> <span class="o">=</span> <span class="n">largest_eigenvalue</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">status</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">~</span><span class="n">is_stable</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">ArpackNoConvergence</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;warning: eigsh ran out of steps. Consider increasing maxiter or&quot;</span>
              <span class="s2">&quot; using other algorithm.&quot;</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">largest_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">,</span> <span class="n">largest_eigenvalue</span>

<span class="k">def</span> <span class="nf">lobpcg_test_negative_definite</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">accept_ratio</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">DEF_STAB_MAXITER</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if symmetric matrix A is negative definite using the LOBPCG method.</span>

<span class="sd">    Does several lobpcg runs with increasing iter_count. Algorithm stops if a run</span>
<span class="sd">    has outcome max_eigv and residual that obey:</span>
<span class="sd">     * max_eigv + accept_ratio * residual &lt; eps -&gt; negative definite (status=0)</span>
<span class="sd">     * max_eigv &gt; eps -&gt; not negative definite (status=1)</span>
<span class="sd">     * total_iters &gt; maxiter -&gt; indeterminate (status=2)</span>

<span class="sd">    The iter_count at the first run is 2 and increased by one every run, and every consecutive</span>
<span class="sd">    run uses the previous eigenvector as starting vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : {sparse matrix, dense matrix, LinearOperator}</span>
<span class="sd">        Matrix to determine if positive definite</span>
<span class="sd">    preconditioner=None : {dense matrix, sparse matrix, LinearOperator, None}</span>
<span class="sd">        Preconditioner to A, should approximate the iverse of A. None means identity matrix.</span>
<span class="sd">    accept_ratio=10 : int</span>
<span class="sd">        Considered converged if max_eigv + accept_ratio * residual &lt; eps.</span>
<span class="sd">    maxiter=200 :</span>
<span class="sd">        Maximum number of iterations. If exceeded; result is indeterminate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    status : int</span>
<span class="sd">        0: negative definite, 1: not negative definite or 2: indeterminate</span>
<span class="sd">    eigenvalue_list (steps,) array</span>
<span class="sd">        Largest eigenvalue found at each iteration.</span>
<span class="sd">    residual_list (steps,) array</span>
<span class="sd">        Residual at each iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">total_iters</span> <span class="o">=</span> <span class="n">iter_count</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lobpcg_out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">preconditioner</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                            <span class="n">retLambdaHistory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retResidualNormsHistory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lobpcg_out</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">max_eigenvalue</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">max_eigenvalue</span><span class="p">)</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">max_eigenvalue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">accept_ratio</span> <span class="o">*</span> <span class="n">residual</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span> <span class="ow">and</span> <span class="n">total_iters</span> <span class="o">&lt;</span> <span class="n">maxiter</span> \
            <span class="ow">and</span> <span class="n">max_eigenvalue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">total_iters</span> <span class="o">&gt;</span> <span class="n">maxiter</span> <span class="o">-</span> <span class="n">iter_count</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_eigenvalue</span><span class="p">,</span> <span class="n">residual</span>
        <span class="n">lobpcg_out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lobpcg</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="o">=</span><span class="n">preconditioner</span><span class="p">,</span>
                                                <span class="n">maxiter</span><span class="o">=</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">retLambdaHistory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">retResidualNormsHistory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">total_iters</span> <span class="o">+=</span> <span class="n">iter_count</span>
        <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lobpcg_out</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_eigenvalue</span><span class="p">,</span> <span class="p">[</span><span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_max_eigv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">new_max_eigv</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">max_eigenvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_eigenvalue</span><span class="p">,</span> <span class="n">new_max_eigv</span><span class="p">)</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">lobpcg_out</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">is_negative_definite</span> <span class="o">=</span> <span class="n">max_eigenvalue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">accept_ratio</span> <span class="o">*</span> <span class="n">residual</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_negative_definite</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">is_negative_definite</span> <span class="o">=</span> <span class="n">is_negative_definite</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">status</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">~</span><span class="n">is_negative_definite</span><span class="p">)</span>
    <span class="n">eigenvalue_list</span><span class="p">,</span> <span class="n">residual_list</span> <span class="o">=</span> <span class="n">max_eigenvalue</span><span class="p">,</span> <span class="n">residual</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">,</span> <span class="n">eigenvalue_list</span><span class="p">,</span> <span class="n">residual_list</span>

</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, MartijnLankhorst.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>