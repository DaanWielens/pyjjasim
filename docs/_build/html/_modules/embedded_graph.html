
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>embedded_graph &#8212; pyjjasim 2.2.4 documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/blank.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">pyjjasim</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../pyjjasim.html">
  pyjjasim API
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
<h3><a href="../index.html">Table of Contents</a></h3>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pyjjasim.html">pyjjasim API</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for embedded_graph</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
<span class="kn">from</span> <span class="nn">pyjjasim.variable_row_array</span> <span class="kn">import</span> <span class="n">VarRowArray</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Embedded Graph Module</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">NotSingleComponentError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">NotPlanarEmbeddingError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">NonSimpleError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">SelfLoopError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">NodeNotExistError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">EdgeNotExistError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="EmbeddedGraph"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph">[docs]</a><span class="k">class</span> <span class="nc">EmbeddedGraph</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for embedded 2D graphs. Can be used to construct faces and check planarity.</span>

<span class="sd">    Definitions:</span>
<span class="sd">     - l-cycle:</span>
<span class="sd">        Cycle generated by traversing the embedded graph always taking the leftmost turn at</span>
<span class="sd">        every node.</span>
<span class="sd">     - face-cycle:</span>
<span class="sd">        An l-cycle with positive oriented area (using shoelace formula). If the graph is planar,</span>
<span class="sd">        face cycles are the boundaries of faces.</span>

<span class="sd">    Requirements:</span>
<span class="sd">     - No self-loops</span>
<span class="sd">     - Simple (no multigraph)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : (N,) array</span>
<span class="sd">        Coordinates of nodes of embedded graph.</span>
<span class="sd">    node1, node2 : (E,) int array in range(N)</span>
<span class="sd">        endpoint nodes of edges in embedded graph. Nodes are referred to by their index in</span>
<span class="sd">        the coordinate arrays.</span>
<span class="sd">    require_single_component=False :</span>
<span class="sd">        If True, an error is raised if the graph is not single-component.</span>
<span class="sd">    require_planar_embedding=False :</span>
<span class="sd">        If True, an error is raised if the graph is not a planar embedding.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NonSimpleError</span>
<span class="sd">        If graph is not simple.</span>
<span class="sd">    SelfLoopError</span>
<span class="sd">        if graph contains self-loops.</span>
<span class="sd">    NotSingleComponentError</span>
<span class="sd">        if graph has disconnected components and require_single_component=True.</span>
<span class="sd">    NotPlanarEmbeddingError</span>
<span class="sd">        If graph in not a planar embedding and require_planar_embedding=True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EmbeddedGraph.__init__"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_edges_are_sorted</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be same size&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_edges_correct_shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_edges_contain_existing_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_no_self_loop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_edges_are_sorted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span> <span class="o">=</span> <span class="n">_edges_are_sorted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_nonsimple</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_v_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_edge_v_array</span><span class="p">()</span>

        <span class="c1"># quantities are computed and stored only when a method needs them.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">require_single_component</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_single_component</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">require_planar_embedding</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_planar_embedding</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_edges"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return node endpoints of all edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        node1, node2 : (E,) int arrays in range(N)</span>
<span class="sd">            Node endpoints of all edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_de_sort_edges</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_edge_ids"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_edge_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return indices of edges with given endpoint nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node1, node2 : arrays in range(N)</span>
<span class="sd">            Endpoints of edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edge_ids : array with same size as node1 in range(E)</span>
<span class="sd">            Returns indices of edges.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        EdgeNotExistError</span>
<span class="sd">            If a queried node-pair does not exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">node1</span> <span class="o">&lt;</span> <span class="n">node2</span>
        <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">node1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">EdgeNotExistError</span><span class="p">(</span><span class="s2">&quot;queried edge that does not exist&quot;</span><span class="p">)</span>
        <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_v_array</span><span class="o">.</span><span class="n">row_ranges</span><span class="p">()</span>
        <span class="n">node1_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="n">starts</span><span class="p">],</span> <span class="n">node1</span><span class="p">)</span>
        <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">starts</span><span class="p">[</span><span class="n">node1_idx</span><span class="p">],</span> <span class="n">ends</span><span class="p">[</span><span class="n">node1_idx</span><span class="p">]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">node2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="n">starts</span><span class="p">]):</span>
            <span class="n">starts</span><span class="p">[</span><span class="n">node2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="n">starts</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">starts</span> <span class="o">&lt;</span> <span class="n">ends</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">EdgeNotExistError</span><span class="p">(</span><span class="s2">&quot;queried edge that does not exist&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="n">starts</span><span class="p">]</span> <span class="o">==</span> <span class="n">node1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="n">starts</span><span class="p">]</span> <span class="o">==</span> <span class="n">node2</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">EdgeNotExistError</span><span class="p">(</span><span class="s2">&quot;queried edge that does not exist&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">[</span><span class="n">starts</span><span class="p">]</span></div>

<div class="viewcode-block" id="EmbeddedGraph.add_nodes"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.add_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add nodes to graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : arrays</span>
<span class="sd">            Coordinates of the nodes to be added to the graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            New graph with nodes added to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.add_edges"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.add_edges">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add edges to graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node1, node2 : arrays in range(N)</span>
<span class="sd">            Endpoints of edges.</span>
<span class="sd">        require_single_component=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not single-component.</span>
<span class="sd">        require_planar_embedding=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not a planar embedding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            New graph with edges added to it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">require_single_component</span><span class="o">=</span><span class="n">require_single_component</span><span class="p">,</span>
                             <span class="n">require_planar_embedding</span><span class="o">=</span><span class="n">require_planar_embedding</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.add_nodes_and_edges"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.add_nodes_and_edges">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add nodes and edges to graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : arrays</span>
<span class="sd">            coordinates of the nodes to be added to the graph</span>
<span class="sd">        node1, node2 : arrays in range(N + x.size)</span>
<span class="sd">            endpoints of edges. The i-th new node must be referred to by index N + i.</span>
<span class="sd">        require_single_component=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not single-component</span>
<span class="sd">        require_planar_embedding=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not a planar embedding</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            new graph with nodes and edges added to it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                             <span class="n">require_single_component</span><span class="o">=</span><span class="n">require_single_component</span><span class="p">,</span>
                             <span class="n">require_planar_embedding</span><span class="o">=</span><span class="n">require_planar_embedding</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.remove_nodes"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.remove_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove nodes from graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_ids : int array in range(N)</span>
<span class="sd">            Indices of nodes to be removed.</span>
<span class="sd">        require_single_component=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not single-component.</span>
<span class="sd">        require_planar_embedding=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not a planar embedding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            New graph with nodes removed from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_count</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">node_map</span><span class="p">[</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">node_map</span><span class="p">)</span> <span class="o">-</span> <span class="n">node_map</span>
        <span class="n">node_map</span><span class="p">[</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">],</span> <span class="n">node_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">]</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">),</span>
                             <span class="n">n1</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">],</span> <span class="n">n2</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">],</span> <span class="n">require_single_component</span><span class="o">=</span><span class="n">require_single_component</span><span class="p">,</span>
                             <span class="n">require_planar_embedding</span><span class="o">=</span><span class="n">require_planar_embedding</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.remove_edges_by_ids"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.remove_edges_by_ids">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edges_by_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_ids</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove edges from graph with edge ids as input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_ids : int array in range(E)</span>
<span class="sd">            Indices of nodes to be removed.</span>
<span class="sd">        require_single_component=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not single-component.</span>
<span class="sd">        require_planar_embedding=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not a planar embedding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            new graph with edges removed from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ids_internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute_inverse</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="n">ids_internal</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="n">ids_internal</span><span class="p">),</span> <span class="n">_edges_are_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">require_single_component</span><span class="o">=</span><span class="n">require_single_component</span><span class="p">,</span>
                             <span class="n">require_planar_embedding</span><span class="o">=</span><span class="n">require_planar_embedding</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.remove_edges"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.remove_edges">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">require_single_component</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">require_planar_embedding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove edges from graph with node endpoints as input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node1, node2 : int arrays in range(N)</span>
<span class="sd">            The indices of node endpoints of edges to be removed.</span>
<span class="sd">        require_single_component=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not single-component.</span>
<span class="sd">        require_planar_embedding=False :</span>
<span class="sd">            If True; raises error if the resulting graph is not a planar embedding.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_graph : :py:attr:`EmbeddedGraph`</span>
<span class="sd">            new graph with edges removed from it.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        EdgeNotExistError</span>
<span class="sd">            If a queried node-pair does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_edges_by_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_ids</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">),</span>
                                        <span class="n">require_single_component</span><span class="o">=</span><span class="n">require_single_component</span><span class="p">,</span>
                                        <span class="n">require_planar_embedding</span><span class="o">=</span><span class="n">require_planar_embedding</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.coo"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.coo">[docs]</a>    <span class="k">def</span> <span class="nf">coo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns coordinates of nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y : (N,) arrays</span>
<span class="sd">            Coordinates of nodes in graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span></div>

<div class="viewcode-block" id="EmbeddedGraph.node_count"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.node_count">[docs]</a>    <span class="k">def</span> <span class="nf">node_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of nodes in graph (abbreviated by N).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span></div>

<div class="viewcode-block" id="EmbeddedGraph.edge_count"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.edge_count">[docs]</a>    <span class="k">def</span> <span class="nf">edge_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of edges in graph (abbreviated by E).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_l_cycles"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_l_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_l_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns for all l-cycles the nodes it traverses in order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_list=False :</span>
<span class="sd">            If true, output is in form of list-of-lists, otherwise concatenated array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes :  list-of-lists or array</span>
<span class="sd">             For all l-cycles the nodes it traverses in order.</span>
<span class="sd">        lengths : (FR,) int array</span>
<span class="sd">            Length of every l-cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_face_nodes</span><span class="p">()</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span>
        <span class="k">if</span> <span class="n">to_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">lengths</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">lengths</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_face_cycles"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_face_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_face_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_list</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns for all face-cycles the nodes it traverses in order. If the graph is planar,</span>
<span class="sd">        these enclose individual faces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_list=False :</span>
<span class="sd">            If true, output is in form of list-of-lists, otherwise concatenated array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes :  list-of-lists or array</span>
<span class="sd">             For all face-cycles the nodes it traverses in order.</span>
<span class="sd">        lengths : (F,) int array</span>
<span class="sd">            Length of every face-cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_face_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">delete_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">)</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">lengths</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">lengths</span></div>

<div class="viewcode-block" id="EmbeddedGraph.face_count"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.face_count">[docs]</a>    <span class="k">def</span> <span class="nf">face_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of face cycles in graph (abbreviated by F). In a planar</span>
<span class="sd">        graph this equals the number of faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_boundary_faces</span><span class="p">())</span></div>

<div class="viewcode-block" id="EmbeddedGraph.l_cycle_count"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.l_cycle_count">[docs]</a>    <span class="k">def</span> <span class="nf">l_cycle_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of l-cycles in graph. (abbreviated by FR)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span></div>

<div class="viewcode-block" id="EmbeddedGraph.is_planar_embedding"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.is_planar_embedding">[docs]</a>    <span class="k">def</span> <span class="nf">is_planar_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns if graph is planar embedding, which is true if edges only intersect at their endpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_count</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_count</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_face_areas"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_face_areas">[docs]</a>    <span class="k">def</span> <span class="nf">get_face_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns areas of face-cycles. These correspond to face-areas is the graph</span>
<span class="sd">        is planar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        areas :  (F,) array</span>
<span class="sd">            Areas of face-cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_areas</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">areas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_l_cycle_areas"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_l_cycle_areas">[docs]</a>    <span class="k">def</span> <span class="nf">get_l_cycle_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns signed areas of l-cycles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        areas :  (FR,) array</span>
<span class="sd">            Signed areas of l-cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_areas</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_l_cycle_centroids"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_l_cycle_centroids">[docs]</a>    <span class="k">def</span> <span class="nf">get_l_cycle_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns centroids of l_cycles in graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y :  (F,) arrays</span>
<span class="sd">            Returns coordinates of centroids of l_cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">six_times_area</span> <span class="o">=</span> <span class="mf">6.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l_cycle_areas</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">six_times_area</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">six_times_area</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">long_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">at_out_index</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span><span class="p">]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span><span class="p">]</span>
        <span class="n">centroid_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">long_mask</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">*</span> <span class="n">X</span><span class="p">))</span> <span class="o">/</span> <span class="n">six_times_area</span>
        <span class="n">centroid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">long_mask</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">*</span> <span class="n">Y</span><span class="p">))</span> <span class="o">/</span> <span class="n">six_times_area</span>
        <span class="k">return</span> <span class="n">centroid_x</span><span class="p">,</span> <span class="n">centroid_y</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_face_centroids"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_face_centroids">[docs]</a>    <span class="k">def</span> <span class="nf">get_face_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns centroids of faces in graph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x, y :  (F,) arrays</span>
<span class="sd">            Returns coordinates of centroids of faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroid_x</span><span class="p">,</span> <span class="n">centroid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l_cycle_centroids</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">centroid_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">),</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">centroid_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_num_components"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_num_components">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns number of connected components of graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_components"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_components">[docs]</a>    <span class="k">def</span> <span class="nf">get_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns components of graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        components :  (N,) int array in range(num_components)</span>
<span class="sd">            Components of graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span></div>

<div class="viewcode-block" id="EmbeddedGraph.split_components"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.split_components">[docs]</a>    <span class="k">def</span> <span class="nf">split_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of individual components of graph as separate EmbeddedGraph objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_components</span><span class="p">()</span>
        <span class="n">num_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_nodes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">components</span> <span class="o">!=</span> <span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_components</span><span class="p">)]</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_boundary_faces"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_boundary_faces">[docs]</a>    <span class="k">def</span> <span class="nf">get_boundary_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns indices of l_cycles that are boundary faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span></div>

<div class="viewcode-block" id="EmbeddedGraph.l_cycle_matrix"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.l_cycle_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">l_cycle_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns cycle matrix build with l_cycles.</span>

<span class="sd">        Cycle matrix is an (F, E) sparse matrix where the i-th row corresponds to the</span>
<span class="sd">        i-th l_cycle. The entry is +1 or -1 if the cycle contains that edge.</span>

<span class="sd">        The value +1 is assigned if traversing the cycle counter clockwise first encounters</span>
<span class="sd">        the endpoint node of the edge with lowest id. If not, -1 is assigned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cycle_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face_edges</span><span class="p">,</span> <span class="n">face_lengths</span><span class="p">,</span> <span class="n">permute</span><span class="p">):</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_lengths</span><span class="p">)</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">face_lengths</span><span class="p">))</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">permute</span><span class="p">[</span><span class="n">face_edges</span> <span class="o">%</span> <span class="n">E</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">face_edges</span> <span class="o">//</span> <span class="n">E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">E</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>

<div class="viewcode-block" id="EmbeddedGraph.face_cycle_matrix"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.face_cycle_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">face_cycle_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns cycle matrix build with face cycles</span>

<span class="sd">        Cycle matrix is an (F, E) sparse matrix where the i-th row corresponds to the</span>
<span class="sd">        i-th face. The entry is +1 or -1 if the cycle contains that edge.</span>

<span class="sd">        The value +1 is assigned if traversing the cycle counter clockwise first encounters</span>
<span class="sd">        the endpoint node of the edge with lowest id. If not, -1 is assigned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="n">nb_face_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_boundary_mask</span><span class="p">())]</span>
        <span class="n">nb_face_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_boundary_mask</span><span class="p">()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_matrix</span><span class="p">(</span><span class="n">nb_face_edges</span><span class="p">,</span> <span class="n">nb_face_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">)</span></div>

<div class="viewcode-block" id="EmbeddedGraph.cut_space_matrix"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.cut_space_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">cut_space_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns cut-space matrix.</span>

<span class="sd">        Cut-space matrix is an (N, E) sparse matrix where the i-th row corresponds to the</span>
<span class="sd">        i-th node. The entry is +1 or -1 if the node is an endpoint of that edge. It is +1</span>
<span class="sd">        if the node is the endpoint with highest idx, -1 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_count</span><span class="p">()</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">))</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">E</span><span class="p">)))]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">E</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.adjacency_matrix"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns adjacency matrix.</span>

<span class="sd">        Adjacency matrix is an (N, N) sparse symmetric matrix where a node-pair</span>
<span class="sd">        entry is 1 if the nodes share an edge, 0 if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_count</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">E</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.get_common_edge_of_l_cycles"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.get_common_edge_of_l_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">get_common_edge_of_l_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">,</span> <span class="n">return_orientation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns index of an edge occurring in both cycles if it exists; otherwise -1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cycle1, cycle2 : int arrays in range(F)</span>
<span class="sd">            Indices referring to l_cycles.</span>
<span class="sd">        return_orientation=False :</span>
<span class="sd">            If True, orientation of edge with respect to cycle pair is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shared_edge : array in range(E) with same size as cycle1,2</span>
<span class="sd">            Edge shared by l_cycle1 and l_cycle2. If multiple exist;</span>
<span class="sd">            returns one with the lowest index.</span>
<span class="sd">        orientation : bool array with same size as cycle1,2 (optional)</span>
<span class="sd">            True if cycle1 passes edge counterclockwise first encountering its</span>
<span class="sd">            node with lowest index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">rows</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:</span><span class="n">E</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">E</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">E</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">&lt;</span> <span class="n">f2</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>

        <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">))</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">[</span><span class="n">sorter</span><span class="p">],</span>  <span class="n">f2</span><span class="p">[</span><span class="n">sorter</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">)])</span>

        <span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cycle1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cycle2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">input_shape</span> <span class="o">=</span> <span class="n">cycle1</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span> <span class="o">=</span> <span class="n">cycle1</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">cycle2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask2</span> <span class="o">=</span> <span class="n">cycle1</span> <span class="o">&lt;</span> <span class="n">cycle2</span>
        <span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask2</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">,</span> <span class="n">cycle1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;fmin&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;fmax&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">)])</span>

        <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">edge_ids</span><span class="p">[</span><span class="n">edge_ids</span> <span class="o">&gt;=</span> <span class="n">E</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">return_orientation</span><span class="p">:</span>
            <span class="n">orientation</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">sorter</span><span class="p">][</span><span class="n">edge_ids</span><span class="p">]</span> <span class="o">^</span> <span class="o">~</span><span class="n">mask2</span>

        <span class="n">found_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">f1</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fmin</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">f2</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fmax</span><span class="p">)</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">sorter</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">]</span>

        <span class="n">edge_ids</span><span class="p">[</span><span class="n">found_mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">return_orientation</span><span class="p">:</span>
            <span class="n">orientation</span><span class="p">[</span><span class="n">found_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">[</span><span class="n">edge_ids</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)],</span> \
                   <span class="n">orientation</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">[</span><span class="n">edge_ids</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)]</span></div>

<div class="viewcode-block" id="EmbeddedGraph.permute_nodes"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.permute_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">permute_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permute node order. Because edges refer to nodes by their position,</span>
<span class="sd">        this also changes node1 and node2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_count</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid permutation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">permutation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">permutation</span><span class="p">]</span>
        <span class="n">inv_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node1</span> <span class="o">=</span> <span class="n">inv_perm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">=</span> <span class="n">inv_perm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_de_sort_edges</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_faces</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.permute_faces"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.permute_faces">[docs]</a>    <span class="k">def</span> <span class="nf">permute_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">permutation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permute face order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_cycle_count</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid permutation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span><span class="p">[</span><span class="n">permutation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recompute_faces</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmbeddedGraph.face_dual_graph"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.face_dual_graph">[docs]</a>    <span class="k">def</span> <span class="nf">face_dual_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_cycle_matrix</span><span class="p">()</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">adj</span><span class="o">.</span><span class="n">col</span>
        <span class="k">return</span> <span class="n">EmbeddedGraph</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_face_centroids</span><span class="p">(),</span> <span class="n">adj</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">adj</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span></div>

<div class="viewcode-block" id="EmbeddedGraph.locate_faces"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.locate_faces">[docs]</a>    <span class="k">def</span> <span class="nf">locate_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get faces whose centroids are closest to queried coordinate.</span>
<span class="sd">        Graph must be planar embedding.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y: arrays :</span>
<span class="sd">            Coordinates at which one wants to locate faces.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        face_ids : int array with same size as x in range(F)</span>
<span class="sd">            Returns indices of located faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar_embedding</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only works for planar embedding&quot;</span><span class="p">)</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_face_centroids</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">face_ids</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">face_ids</span><span class="p">,</span> <span class="n">locator</span></div>

<div class="viewcode-block" id="EmbeddedGraph.plot"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedGraph.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cycles</span><span class="o">=</span><span class="s2">&quot;face_cycles&quot;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
             <span class="n">show_node_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_edge_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_face_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">face_shrink_factor</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">_face_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">,</span> <span class="n">f_shrink</span><span class="p">):</span>
            <span class="n">xp</span> <span class="o">=</span> <span class="n">f_shrink</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f_shrink</span><span class="p">)</span> <span class="o">*</span> <span class="n">xcn</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="n">f_shrink</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f_shrink</span><span class="p">)</span> <span class="o">*</span> <span class="n">ycn</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coo</span><span class="p">()</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[((</span><span class="n">x</span><span class="p">[</span><span class="n">n1</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">n1</span><span class="p">[</span><span class="n">i</span><span class="p">]]),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n2</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">n2</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n1</span><span class="p">))]</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_node_ids</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">show_edge_ids</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span>  <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">n2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="p">))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_cycles</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">cycles</span> <span class="o">==</span> <span class="s2">&quot;face_cycles&quot;</span><span class="p">:</span>
                <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_face_centroids</span><span class="p">()</span>
                <span class="n">pn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_face_cycles</span><span class="p">(</span><span class="n">to_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">pn</span><span class="p">)):</span>
                    <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_face_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">,</span> <span class="n">face_shrink_factor</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">show_face_ids</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="p">(</span><span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cycles</span> <span class="o">==</span> <span class="s2">&quot;l_cycles&quot;</span><span class="p">:</span>
                <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l_cycle_centroids</span><span class="p">()</span>
                <span class="n">pn</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_l_cycles</span><span class="p">(</span><span class="n">to_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">b_mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_non_boundary_mask</span><span class="p">()</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">pn</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">b_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yp</span><span class="p">,</span> <span class="n">yp</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                     <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">show_face_ids</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="p">(</span><span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_face_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">,</span> <span class="n">face_shrink_factor</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">show_face_ids</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="p">(</span><span class="n">xcn</span><span class="p">,</span> <span class="n">ycn</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

            <span class="n">lc1</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span></div>

    <span class="k">def</span> <span class="nf">_assert_edges_correct_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;node1 and node2 must be same size&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_edges_contain_existing_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">NodeNotExistError</span><span class="p">(</span><span class="s2">&quot;node1,2 values must be in range(N)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_single_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_components</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotSingleComponentError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assert_planar_embedding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar_embedding</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NotPlanarEmbeddingError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assert_no_self_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SelfLoopError</span><span class="p">(</span><span class="s2">&quot;no edge is allowed to have identical end nodes.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_nonsimple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="k">raise</span> <span class="n">NonSimpleError</span><span class="p">(</span><span class="s2">&quot;no duplicate edges allowed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assign_edge_v_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_v_array</span> <span class="o">=</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">))))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_v_array</span>

    <span class="k">def</span> <span class="nf">_sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span>
        <span class="n">nn1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">)</span>
        <span class="n">nn2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span> <span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">nn2</span><span class="p">,</span> <span class="n">nn1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_permute_inverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span> <span class="o">=</span> <span class="n">nn1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">],</span> <span class="n">nn2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_permute</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_de_sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nn1</span><span class="p">,</span> <span class="n">nn2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_permute_inverse</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_permute_inverse</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span><span class="p">,</span> <span class="n">nn2</span><span class="p">,</span> <span class="n">nn1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_flip</span><span class="p">,</span> <span class="n">nn1</span><span class="p">,</span> <span class="n">nn2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset_precomputed_quantities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_assign_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_l_cycles</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span> <span class="o">=</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assign_face_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="n">e_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="n">e_idx</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_assign_roll_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_face_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_assign_determinant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_roll_ids</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_assign_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_determinant</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">determinant</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assign_boundary_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_areas</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">areas</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_recompute_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_precomputed_quantities</span><span class="p">()</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_permutation</span>
        <span class="n">inv_permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_face_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_areas</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_determinant</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_roll_ids</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_lengths</span><span class="p">[</span><span class="n">permutation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas</span><span class="p">[</span><span class="n">permutation</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">determinant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">roll_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span> <span class="o">=</span> <span class="n">inv_permutation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span> <span class="o">=</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces_v_array</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">permutation</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_edge_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a one-to-one map over directed edges, where the image contains the edge</span>
<span class="sd">        which is encountered next when traversing the graph moving counter-clockwise.</span>

<span class="sd">        Used to generate faces by repeating indexing: e_(i+1) = map[e_i]</span>

<span class="sd">        map: np.arange(2*E) -&gt; sorted_out_edge_directed</span>

<span class="sd">        Output:</span>
<span class="sd">        sorted_out_edge_directed    (2*E,) in range(2*E)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">counter_clockwise</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">edge_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">)</span>

        <span class="c1"># construct neighbour structure</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="n">VarRowArray</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="n">neighbour_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">edge_count</span><span class="p">),</span> <span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ns</span><span class="p">)]</span>
        <span class="n">neighbour_node_self</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">neighbours</span><span class="o">.</span><span class="n">rows</span><span class="p">()]</span>
        <span class="n">neighbour_node_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="n">neighbour_edges</span><span class="p">]</span> <span class="o">==</span> <span class="n">neighbour_node_self</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">node2</span><span class="p">[</span><span class="n">neighbour_edges</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">node1</span><span class="p">[</span><span class="n">neighbour_edges</span><span class="p">])</span>

        <span class="c1"># sort neighbour in-dimension by ascending angle</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">neighbour_node_other</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">neighbour_node_self</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">neighbour_node_other</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">neighbour_node_self</span><span class="p">])</span>
        <span class="n">angle_arg_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">neighbour_node_self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span> <span class="o">+</span> <span class="n">angles</span><span class="p">)</span>
        <span class="n">neighbour_edges</span> <span class="o">=</span> <span class="n">neighbour_edges</span><span class="p">[</span><span class="n">angle_arg_sort</span><span class="p">]</span>
        <span class="n">neighbour_node_other</span> <span class="o">=</span> <span class="n">neighbour_node_other</span><span class="p">[</span><span class="n">angle_arg_sort</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">to_directed</span><span class="p">(</span><span class="n">edge_nr</span><span class="p">,</span> <span class="n">edge_direction</span><span class="p">,</span> <span class="n">edge_count</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">edge_nr</span> <span class="o">+</span> <span class="n">edge_count</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">edge_direction</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

        <span class="c1"># create combined-index for input edges of the map</span>
        <span class="n">neighbour_edges_direction</span> <span class="o">=</span> <span class="n">neighbour_node_other</span> <span class="o">&lt;</span> <span class="n">neighbour_node_self</span>
        <span class="n">in_edge_combined_index</span> <span class="o">=</span> <span class="n">to_directed</span><span class="p">(</span><span class="n">neighbour_edges</span><span class="p">,</span> <span class="n">neighbour_edges_direction</span><span class="p">,</span> <span class="n">edge_count</span><span class="p">)</span>

        <span class="c1"># find the map from every (combined index) edge to the next edge in (counter-)-clockwise direction</span>
        <span class="n">edges_map</span> <span class="o">=</span> <span class="n">neighbours</span><span class="o">.</span><span class="n">roll</span><span class="p">()</span> <span class="k">if</span> <span class="n">counter_clockwise</span> <span class="k">else</span> <span class="n">neighbours</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># find the combined index of the output edges of the map</span>
        <span class="n">out_edge_directed</span> <span class="o">=</span> <span class="n">to_directed</span><span class="p">(</span><span class="n">neighbour_edges</span><span class="p">,</span> <span class="o">~</span><span class="n">neighbour_edges_direction</span><span class="p">,</span> <span class="n">edge_count</span><span class="p">)[</span><span class="n">edges_map</span><span class="p">]</span>

        <span class="c1"># sort the edge-map based on the (combined index of the) input edges</span>
        <span class="n">sorted_out_edge_directed</span> <span class="o">=</span> <span class="n">out_edge_directed</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">in_edge_combined_index</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">sorted_out_edge_directed</span>

    <span class="k">def</span> <span class="nf">_construct_l_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes l-cycles of the embedded graph. This is done using repeated iteration over the</span>
<span class="sd">        one-to-one map over directed edges computed with _get_edge_map(). It starts with all</span>
<span class="sd">        edges pointing from lowest to highest node to ensure all cycles are found.</span>

<span class="sd">        Used to generate cycles by repeating indexing: e_(i+1) = map[e_i]</span>

<span class="sd">        map: np.arange(2*E) -&gt; sorted_out_edge_directed</span>

<span class="sd">        Output:</span>
<span class="sd">        sorted_out_edge_directed    (2*E,) in range(2*E)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_map</span><span class="p">()</span>
        <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">())</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cycles</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">edge_ids</span>
        <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">current_cycle_length</span><span class="p">,</span> <span class="n">out_cycles</span><span class="p">,</span> <span class="n">out_cycle_lengths</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># iteration doing counter-clockwise walks through the graphs starting from each junction</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edge_ids</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="n">edge_ids</span><span class="p">]</span>
            <span class="n">is_terminated</span> <span class="o">=</span> <span class="n">edge_ids</span> <span class="o">==</span> <span class="n">cycles</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_terminated</span><span class="p">):</span>
                <span class="n">out_cycle_lengths</span><span class="p">,</span> <span class="n">out_cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store_terminated_cycles</span><span class="p">(</span><span class="n">cycles</span><span class="p">[:</span><span class="n">current_cycle_length</span><span class="p">,</span> <span class="n">is_terminated</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                            <span class="n">out_cycle_lengths</span><span class="p">,</span> <span class="n">out_cycles</span><span class="p">)</span>
                <span class="n">cycles</span><span class="p">,</span> <span class="n">cycle_lengths</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[:,</span> <span class="o">~</span><span class="n">is_terminated</span><span class="p">],</span> <span class="n">cycle_lengths</span><span class="p">[</span><span class="o">~</span><span class="n">is_terminated</span><span class="p">]</span>
                <span class="n">edge_ids</span> <span class="o">=</span> <span class="n">edge_ids</span><span class="p">[</span><span class="o">~</span><span class="n">is_terminated</span><span class="p">]</span>
            <span class="n">cycles</span><span class="p">[</span><span class="n">current_cycle_length</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">edge_ids</span>
            <span class="n">current_cycle_length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cycles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">current_cycle_length</span><span class="p">):</span>
                <span class="n">cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycles</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cycles</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_cycles</span><span class="p">,</span> <span class="n">out_cycle_lengths</span>

    <span class="k">def</span> <span class="nf">_store_terminated_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminated_cycles</span><span class="p">,</span> <span class="n">out_cycle_lengths</span><span class="p">,</span> <span class="n">out_cycles</span><span class="p">):</span>
        <span class="c1"># roll cycles until the lowest node index is in the first column (so its easier to remove duplicate cycles)</span>
        <span class="n">cycle_cnt</span><span class="p">,</span> <span class="n">cycle_len</span> <span class="o">=</span> <span class="n">terminated_cycles</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">terminated_cycles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cycle_cnt</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cycle_len</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">terminated_cycles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">%</span> <span class="n">cycle_len</span><span class="p">]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cycles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1">#</span>
        <span class="c1"># cycles = np.unique(cycles, axis=0)</span>

        <span class="n">out_cycle_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_cycle_lengths</span><span class="p">,</span> <span class="n">cycle_len</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cycles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">out_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_cycles</span><span class="p">,</span> <span class="n">cycles</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">out_cycle_lengths</span><span class="p">,</span> <span class="n">out_cycles</span>

    <span class="k">def</span> <span class="nf">_non_boundary_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_cycle_count</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_cycle_space_solve_for_integral_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the equation: A @ x = b (where A = cycle_matrix, without boundary faces).</span>
<span class="sd">        If b is integral (contain only integers), the output array x will also be integral.</span>

<span class="sd">        input:  b (..., F)</span>
<span class="sd">        output: x (..., E)</span>

<span class="sd">        Notes:</span>
<span class="sd">            - The equation is underdetermined, so the solution x is not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_boundary_faces</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_num_components</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_planar_embedding</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only implemented for single component planar embedding&quot;</span><span class="p">)</span>

        <span class="n">E</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_count</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="n">b_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
        <span class="n">b_tally</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># insert boundary face in b_tally</span>
        <span class="n">b_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_face_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b_tally</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">b_tally</span><span class="p">[:,</span> <span class="p">:</span><span class="n">b_idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b_tally</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">b_tally</span><span class="p">[:,</span> <span class="n">b_idx</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># do depth first search, resulting in cur (current node of tree) and prev (parent node of cur)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_cycle_matrix</span><span class="p">()</span>
        <span class="n">cur</span><span class="p">,</span> <span class="n">predecessor</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">depth_first_order</span><span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">b_idx</span><span class="p">)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">predecessor</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
        <span class="n">prev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># find map of edge between pair of faces. signs returns +1 if face1 counterclockwise passes resulting edge in its own direction.</span>
        <span class="n">juncs</span><span class="p">,</span> <span class="n">orientation_in_face_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_common_edge_of_l_cycles</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">return_orientation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sgns</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">orientation_in_face_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">))</span>

        <span class="c1"># construct x at each edge by passing through the tree in reverse.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">F</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">b_tally</span><span class="p">[:,</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_tally</span><span class="p">[:,</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">x</span><span class="p">[:,</span> <span class="n">juncs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_tally</span><span class="p">[:,</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">sgns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">b_tally</span><span class="p">[:,</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># check if resulting x solves A @ x == b</span>
        <span class="n">b_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_boundary_mask</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;failed integral solve of cycle space linear problem&quot;</span><span class="p">)</span>

        <span class="c1"># return x</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_shape</span><span class="p">))</span></div>

<div class="viewcode-block" id="EmbeddedSquareGraph"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedSquareGraph">[docs]</a><span class="k">class</span> <span class="nc">EmbeddedSquareGraph</span><span class="p">(</span><span class="n">EmbeddedGraph</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Embedded graph for a square lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    count_x, count_y : int scalar</span>
<span class="sd">        Node count of square lattice in x- and y-direction respectively.</span>
<span class="sd">    x_scale, y_scale=1.0 : float scalar</span>
<span class="sd">        Stretch factors for square lattice in x- and y-direction respectively.</span>
<span class="sd">        Bottom-left node is at origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="EmbeddedSquareGraph.__init__"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedSquareGraph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_x</span><span class="p">,</span> <span class="n">count_y</span><span class="p">,</span>  <span class="n">x_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">count_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">count_x</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">count_x</span> <span class="o">*</span> <span class="n">count_y</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">count_y</span><span class="p">,</span> <span class="n">count_x</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EmbeddedHoneycombGraph"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedHoneycombGraph">[docs]</a><span class="k">class</span> <span class="nc">EmbeddedHoneycombGraph</span><span class="p">(</span><span class="n">EmbeddedGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Embedded graph for a honeycomb lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    count_x, count_y : int scalar</span>
<span class="sd">        The amount of times the unit cell (with shape /¯\ and has 4 nodes) is</span>
<span class="sd">        repeated in the x- and y-direction; generating a honeycomb lattice.</span>
<span class="sd">    x_scale, y_scale=1.0 : float scalar</span>
<span class="sd">        Stretch factors for honeycomb lattice in x- and y-direction respectively.</span>
<span class="sd">        Bottom-left node is at origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="EmbeddedHoneycombGraph.__init__"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedHoneycombGraph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_x</span><span class="p">,</span> <span class="n">count_y</span><span class="p">,</span> <span class="n">x_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">count_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">count_x</span><span class="p">]</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">nodes_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">nodes_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">),</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">),</span> <span class="n">y1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">count_x</span> <span class="o">*</span> <span class="n">count_y</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">count_y</span><span class="p">,</span> <span class="n">count_x</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">count_x</span> <span class="o">*</span> <span class="n">count_y</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span>   <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="n">s</span><span class="p">,</span>   <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:],</span>    <span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">,</span>  <span class="n">idx</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">nodes1</span><span class="p">]))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">nodes2</span><span class="p">]))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># remove_node_ids = [0, idx[0, -1] + 3 * s]</span>
        <span class="c1"># self.remove_nodes(remove_node_ids)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodes_x</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span> <span class="n">nodes_y</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">,</span> <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="EmbeddedTriangularGraph"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedTriangularGraph">[docs]</a><span class="k">class</span> <span class="nc">EmbeddedTriangularGraph</span><span class="p">(</span><span class="n">EmbeddedGraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Embedded graph for a triangular lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    count_x, count_y : int scalar</span>
<span class="sd">        The amount of times the unit cell (with shape / and has 2 nodes) is</span>
<span class="sd">        repeated in the x- and y-direction; generating a triangular lattice.</span>
<span class="sd">    x_scale, y_scale=1.0 : float scalar</span>
<span class="sd">        Stretch factors for triangular lattice in x- and y-direction respectively.</span>
<span class="sd">        Bottom-left node is at origin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="EmbeddedTriangularGraph.__init__"><a class="viewcode-back" href="../embedded_graph.html#embedded_graph.EmbeddedTriangularGraph.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_x</span><span class="p">,</span> <span class="n">count_y</span><span class="p">,</span> <span class="n">x_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">count_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">count_x</span><span class="p">]</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">nodes_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nodes_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">count_x</span> <span class="o">*</span> <span class="n">count_y</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">count_y</span><span class="p">,</span> <span class="n">count_x</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">count_x</span> <span class="o">*</span> <span class="n">count_y</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span>   <span class="n">idx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">s</span><span class="p">,</span> <span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span>  <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:],</span>    <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span>     <span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">s</span><span class="p">,</span>  <span class="n">idx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">s</span><span class="p">)</span>
        <span class="n">nodes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">nodes1</span><span class="p">]))</span>
        <span class="n">nodes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">nodes2</span><span class="p">]))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nodes_x</span> <span class="o">*</span> <span class="n">x_scale</span><span class="p">,</span> <span class="n">nodes_y</span> <span class="o">*</span> <span class="n">y_scale</span><span class="p">,</span> <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span></div></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, MartijnLankhorst.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>